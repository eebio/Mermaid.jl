var documenterSearchIndex = {"docs":
[{"location":"is_mermaid_right_for_me/#Is-Mermaid-right-for-me?","page":"Is Mermaid right for me?","title":"Is Mermaid right for me?","text":"This page will walk through the benefits and drawbacks of using Mermaid, what it can do, what it does well, what it can't do and what it does poorly.","category":"section"},{"location":"is_mermaid_right_for_me/#Comparison-against-ModelingToolkit.jl","page":"Is Mermaid right for me?","title":"Comparison against ModelingToolkit.jl","text":"ModelingToolkit.jl is an acausal modeling language, where you specify symbolic forms of your models, which can then be connected together, and compiled into a DifferentialEquations.jl problem.\n\nIn short, if your whole system can be expressed in ModelingToolkit and solved (mostly equivalently, the combined system can be solved in DifferentialEquations or JumpProcesses), then it is probably better solved through ModelingToolkit rather than Mermaid. The acausal connections lead to better accuracy and stability of the final solve.\n\nThe most notable exception to this is multirate solvers. Mermaid naturally has components solved through different solvers, on different (possibly adaptive) timescales. Multirate and multisolver functionality is limited in DifferentialEquations.\n\nwarning: Multi-rate solvers\nUsing multirate solver for differential equations typically comes with a lower order accuracy on the connected variables. If you are unsure if a multirate solver is suitable, it is likely better to favour the solver algorithms in DifferentialEquations and use ModelingToolkit to perform the connections.\n\nIf only part of the whole system can be expressed in ModelingToolkit, you may still be able to benefit from ModelingToolkit features. Combining the relevant components together through ModelingToolkit and then converting that System to a component to connect through Mermaid allows you to benefit from all ModelingToolkit features possible, while still having the flexibility to connect outside the ModelingToolkit ecosystem.","category":"section"},{"location":"examples/duplicated_components/#Advanced-Duplicated-Components","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"You may have seen us use duplicated components in the Tutorial. This is a very powerful tool that lets you efficiently create many instances of a component integrator, each with their own state that can be stepped independently. In the Tutorial, we used duplicated components to create lots of instances of the tree ODE model, so every tree could be tracked independently. Rather than creating 640 components, each with its own integrator - we create 640 state vectors, reducing the memory requirements for the duplicated component.\n\nHowever, while this functionality is useful, it is not always possible to specify the number of instances a priori. For example, we may have wanted trees that die to be removed from the simulation, or new trees to be created over time.\n\nFor this reason, it is also possible to create duplicated components with a variable/unknown number of instances.","category":"section"},{"location":"examples/duplicated_components/#Setup","page":"Advanced Duplicated Components","title":"Setup","text":"For this example, we are going to create an agent-based model of a cell population with each cell goverened by a simple growth model tracking protein mass which is dependent on a spatial nutrient distribution and the number of nearby cells.\n\nusing OrdinaryDiffEq, Agents, Random, Mermaid, CairoMakie\nusing LinearAlgebra: norm\nRandom.seed!(1) # hide\n\nfunction cell!(du, u, p, t)\n    nutrients = u[1]\n    du[1] = 0\n    uptake = 2 * nutrients / (1 + nutrients)\n    decay = 0.1 * (1+u[2]/10)\n    du[2] = uptake - decay\nend\n\nu0 = [1.0, 1.0]\ntspan = (0.0, 250.0)\nprob = ODEProblem(cell!, u0, tspan)\nusing Mermaid\ncomp1 = DEComponent(prob, Rodas5();\n    name=\"cell\", state_names=Dict(\"nutrients\" => 1, \"mass\" => 2),\n)\n\n@agent struct Cell(ContinuousAgent{2,Float64})\n    mass::Float64 # Cell mass is informed by ODE model\n    nutrients::Float64 # Local nutrient availability\nend\n\nfunction colony(; n_cells=3, n_nodes=5, griddims=(40, 40), seed=2)\n    space = ContinuousSpace(griddims; periodic=true)\n    rng = Random.MersenneTwister(seed)\n    nodes = [rand(2) .* griddims for _ in 1:n_nodes]\n    colony = StandardABM(Cell, space; rng, (agent_step!)=cell_step!, properties=Dict(:nodes => nodes))\n    for _ in 1:n_cells\n        vel = rand(2) .- 0.5\n        mass = rand()\n        nutrients = rand()\n        add_agent!(colony, vel, 1, 1)\n    end\n    return colony\nend\n\nfunction wrap_periodic(pos, dims)\n    return SVector{length(pos)}(mod.(pos, dims))\nend\n\nfunction periodic_distance(a, b, dims)\n    # Computes minimum image distance between points a and b in periodic box of size dims\n    d = abs.(a .- b)\n    return norm(min.(d, dims .- d))\nend\n\nfunction nutrients(pos, colony)\n    nutrients = 0.0\n    spread = 7.0\n    dims = abmspace(colony).extent\n    for node in colony.nodes\n        # Calculate periodic distance to node\n        dist = periodic_distance(node, pos, dims)\n        nutrients += exp(-dist^2 / spread^2)/2 # Gaussian decay\n    end\n    return nutrients\nend\n\nfunction cell_step!(cell, colony)\n    # Move away from nearby agents\n    speed = 0.5\n    for cell2 in nearby_agents(cell, colony, 0.5)\n        cell.vel -= speed * (cell2.pos - cell.pos) / norm(cell2.pos - cell.pos)^2\n    end\n    # Max speed\n    if norm(cell.vel) > speed\n        cell.vel = speed * cell.vel / norm(cell.vel)\n    end\n    # Walk and apply chemotaxis\n    oldnutrients = nutrients(cell.pos, colony)\n    walk!(cell, cell.vel, colony)\n    newnutrients = nutrients(cell.pos, colony)\n    if newnutrients < oldnutrients\n        # If nutrients decrease, random direction on next iteration\n        cell.vel += rand(2) .- 0.5\n    end\n    # Update nutrients of cell, sharing between neighboring\n    cell.nutrients = nutrients(cell.pos, colony)/(length(collect(nearby_ids(cell, colony, 0.5)))+1)\n    # If large mass, split into two\n    splitmass = 15\n    if cell.mass > splitmass\n        dims = abmspace(colony).extent\n        for m in (splitmass/2, cell.mass - splitmass/2)\n            new_pos = wrap_periodic(cell.pos + rand(2) .- 0.5, dims)\n            add_agent!(new_pos, colony; vel=cell.vel, mass=m, nutrients=0)\n        end\n        remove_agent!(cell, colony)\n    end\n    if cell.mass < 0\n        remove_agent!(cell, colony)\n    end\nend\n\npop = colony()\n\ncomp2 = AgentsComponent(pop;\n    name=\"colony\", state_names=Dict(\"mass\" => :mass, \"nutrients\" => :nutrients)\n)\n\nconn1 = Connector(inputs=[\"colony.nutrients\"], outputs=[\"cell.nutrients\"])\nconn2 = Connector(inputs=[\"cell.mass\"], outputs=[\"colony.mass\"])\n\nnothing # hide","category":"section"},{"location":"examples/duplicated_components/#Flexible-Duplicated-Components","page":"Advanced Duplicated Components","title":"Flexible Duplicated Components","text":"If we don't provide any value for the instances field when creating the duplicated component, it will be created as a flexible duplicated component, letting a special input called #ids give the indexes of the current states (any indexes not specified in #ids are removed, and any state indexes specified in #ids that are not current states are created). Some components, like AgentComponents, already have pre-made special outputs for the #ids which we can use to couple duplicated components to an Agent-based model.\n\ndup_comp = DuplicatedComponent(comp1, [];\n    default_state=u0,\n)\nconn3 = Connector(inputs=[\"colony.#ids\"], outputs=[\"cell.#ids\"])\n\nnothing # hide\n\nnote: Sorting of Connectors\nYou may wonder about the order that connectors are applied. If we adjusted the IDs after applying conn2, we would be using an old value for IDs. Generally, we utilise the order specified in the MermaidProblem. For this reason, the #ids from conn3 is applied first, as will be specified in the order of the connectors vector.","category":"section"},{"location":"examples/duplicated_components/#Solving-and-visualisation","page":"Advanced Duplicated Components","title":"Solving and visualisation","text":"function make_nutrient_heatarray(colony; gridsize=(40, 40))\n    arr = zeros(Float64, gridsize...)\n    xs = range(0, stop=abmspace(colony).extent[1], length=gridsize[1])\n    ys = range(0, stop=abmspace(colony).extent[2], length=gridsize[2])\n    for (i, x) in enumerate(xs), (j, y) in enumerate(ys)\n        arr[i, j] = nutrients(SVector(x, y), colony)\n    end\n    return arr\nend\n\nfig, ax = abmplot(pop; agent_color=:black, agent_marker=:circle, agent_size=x->x.mass+3,\n    heatarray=make_nutrient_heatarray, heatkwargs=(colormap=:Greens_5,))\nio = VideoStream(fig; framerate=10)\nfunction plot_input(model)\n    empty!(ax)\n    abmplot!(ax, model; agent_color=:black, agent_marker=:circle, agent_size=x -> x.mass + 3,\n        heatarray=make_nutrient_heatarray, heatkwargs=(colormap=:Greens_5,))\n    ax.title = \"Time: $(round(abmtime(model))), Population: $(nagents(model))\"\n    recordframe!(io)\nend\n\nconn4 = Connector(\n    inputs=[\"colony.#model\"],\n    outputs=Vector{String}(),\n    func=(model) -> plot_input(model)\n)\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn3, conn1, conn2, conn4], tspan=tspan)\nalg = MinimumTimeStepper()\nsol = solve(mp, alg)\n\nsave(\"cell_colony.mp4\", io)\n\nnothing # hide\n\n(Image: An animation of the cell colony simulation)","category":"section"},{"location":"examples/spatial_maps/#Spatial-maps","page":"Spatial maps","title":"Spatial maps","text":"When connecting multiple spatial models, we may be required to define a mapping function from the coordinate system of 1 component to another. For example, a PDE component is solved through MethodOfLines which will have some specified discretization, but a connected Agent-based model may have continuous positions, or discrete positions on a different resolution. We provide a handful of tools for mapping between two different spaces.\n\nTODO","category":"section"},{"location":"interface/#Mermaid-Interface","page":"Mermaid Interface","title":"Mermaid Interface","text":"In this section, we will:\n\nSee the integrator interface that Mermaid uses,\nFind out how this fits with CommonSolve,","category":"section"},{"location":"interface/#Interface-requirements","page":"Mermaid Interface","title":"Interface requirements","text":"The interface used in Mermaid is compatible with, and uses, the SciML CommonSolve interface. In particular, each Component is some immutable problem type that stores required data to solve a Component (for example, an ODEProblem). We then also have an Integrator for each Component which stores the current state and handles solving over time.","category":"section"},{"location":"interface/#Component","page":"Mermaid Interface","title":"Component","text":"A component should be immutable and store all of the information required to solve a given sub-problem/model:\n\nIt should also have implementations of the following functions:\n\nIf the component has fields for name and timestep, then those functions don't need to be implemented.","category":"section"},{"location":"interface/#Integrator","page":"Mermaid Interface","title":"Integrator","text":"A ComponentIntegrator is a mutable struct which can be freely modified over a simulation, since it will be typically discarded at the end. It only stores the current state of that component, and has some associated functions for handling this state.","category":"section"},{"location":"interface/#Functions","page":"Mermaid Interface","title":"Functions","text":"Most of the interface for Mermaid is built around functions that manipulate the integrator state.","category":"section"},{"location":"interface/#step!","page":"Mermaid Interface","title":"step!","text":"The step! function should advance the ComponentIntegrator one time step (defined by timestep(ComponentIntegrator)).","category":"section"},{"location":"interface/#init","page":"Mermaid Interface","title":"init","text":"The init function takes as inputs a Component and returns the corresponding ComponentIntegrator.","category":"section"},{"location":"interface/#getstate-and-setstate!","page":"Mermaid Interface","title":"getstate and setstate!","text":"The function getstate reads the state of an AbstractComponentIntegrator at a given ConnectedVariable and returns it. The setstate! function similarly mutates the current state of the ComponentIntegrator to assign an inputted value to the ConnectedVariable. Additionally, getstate and setstate! should have methods that do not take a ConnectedVariable, and instead return the full state (in a form that should be compatible between the two functions, but need not be documented).\n\nThe function signatures should be getstate(integrator, variable)/setstate!(integrator, variable, value) and getstate(integrator)/setstate!(integrator, state).","category":"section"},{"location":"interface/#gettime-and-settime!","page":"Mermaid Interface","title":"gettime and settime!","text":"Simply returns the current simulated time of a ComponentIntegrator. Defaults to calling getstate and setstate! with the special variable \"#time\".\n\nThese functions don't need to be defined for new components, but getstate and setstate! should handle the \"#time\" special variable.","category":"section"},{"location":"interface/#Other-functions","page":"Mermaid Interface","title":"Other functions","text":"The interface for a Component is also required to be satisfied for a ComponentIntegrator. That is, implementations of name, timestep, and variables should exist.\n\nIf the ComponentIntegrator has a field/property for the Component called component, then these functions don't need new implementations.","category":"section"},{"location":"interface/#Variable-Names","page":"Mermaid Interface","title":"Variable Names","text":"Mermaid has its own interface for connections too. A Connector uses instances of ConnectedVariables as part of applying the connections. If you want to write your own components, it is worth learning how the ConnectedVariables are defined.\n\nWe can see that each ConnectedVariable has two names, the first is the component name and the second is the variable name (which should match state_names for that component).\n\nIt also has a variable index, which allows you to access only some parts of a full vector. For example, you may index on only some agents in an AgentsComponent.\n\nFinally, it has a duplicated index. Like the variable index, it allows you to act on some subset, but in this case, it is a subset of integrators from a DuplicatedComponent.\n\nA ConnectedVariable can also be constructed from a single string input, ie ConnectedVariable(\"component[duplicatedindex].variable[variableindex]\").","category":"section"},{"location":"interface/#Examples","page":"Mermaid Interface","title":"Examples","text":"To see some examples, look in the ext directory on GitHub.","category":"section"},{"location":"interface/#Mermaid.name-interface","page":"Mermaid Interface","title":"Mermaid.name","text":"name(int::AbstractComponentIntegrator)\nname(comp::AbstractComponent)\n\nGet the name of the integrator or component.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.timestep-interface","page":"Mermaid Interface","title":"Mermaid.timestep","text":"timestep(int::AbstractComponent)\ntimestep(comp::AbstractComponentIntegrator)\n\nGet the proposed time step of the integrator or component. It can depend on the current     state.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.variables-interface","page":"Mermaid Interface","title":"Mermaid.variables","text":"variables(comp::AbstractComponentIntegrator)\nvariables(comp::AbstractComponent)\n\nRetrieve the variable names of a component.\n\nArguments\n\ncomp::Union{AbstractComponent, AbstractComponentIntegrator}: The component (or component   integrator) whose variable names are to be retrieved.\n\nReturns\n\nA collection of variable names (as strings) associated with the component. This includes   all special variables such as #time and #model if applicable.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CommonSolve.step!-interface","page":"Mermaid Interface","title":"CommonSolve.step!","text":"step!(int::AbstractMermaidIntegrator)\nstep!(int::AbstractComponentIntegrator)\n\nAdvance the state of the integrator int by one time step.\n\nArguments\n\nint::Union{AbstractMermaidIntegrator, AbstractComponentIntegrator}: The integrator to   advance.\n\n\n\n\n\nCommonSolve.step!(iter, args...; kwargs...)\n\nProgress the iterator object (the one returned by CommonSolve.init). The additional arguments typically describe how much to progress the iterator for, and are implementation-specific.\n\n\n\n\n\n","category":"function"},{"location":"interface/#CommonSolve.init-interface","page":"Mermaid Interface","title":"CommonSolve.init","text":"init(prob::MermaidProblem, alg::MermaidSolver; save_vars=[])\ninit(comp::AbstractComponent)\n\nInitialises an integrator (MermaidIntegrator or AbstractComponentIntegrator)     for the given MermaidProblem/AbstractComponent.\n\nArguments\n\nprob::MermaidProblem: The hybrid problem to be solved.\nalg::AbstractMermaidSolver: The AbstractMermaidSolver algorithm to be used for   solving the problem.\ncomp::AbstractComponent: The component to be initialised.\n\nKeyword Arguments\n\nsave_vars=[]: Which variables to save in the solution. Defaults to all non-special   variables.\n\nReturns\n\nMermaidIntegrator: The initialized integrator for the problem.\n\n\n\n\n\niter = CommonSolve.init(args...; kwargs...)\n\nCreates an iterator or cache object to hold a problem prob and a solver algorithm alg to be passed to solve! or step!. Generally, the interface is:\n\niter = CommonSolve.init(prob::ProblemType, alg::SolverType; kwargs...)::IterType\nCommonSolve.solve!(iter)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms. The iter type will be different for the different problem types.\n\nThe object returned by init allows more direct control over the internal solving process, and users shouldn't generally need to handle it.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.getstate-interface","page":"Mermaid Interface","title":"Mermaid.getstate","text":"getstate(comp::AbstractComponentIntegrator)\ngetstate(comp::AbstractComponentIntegrator, key)\n\nRetrieve the state of a component.\n\nArguments\n\ncomp::AbstractComponentIntegrator: The component whose state is to be retrieved.\nkey: The key specifying which part of the component's state to retrieve.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.setstate!-interface","page":"Mermaid Interface","title":"Mermaid.setstate!","text":"setstate!(comp::AbstractComponentIntegrator, state)\nsetstate!(comp::AbstractComponentIntegrator, key, value)\n\nSet the state of a component.\n\nArguments\n\ncomp::AbstractComponentIntegrator: The component whose state is to be set.\nstate: The new state to set for the entire component.\nkey: The key specifying which part of the component's state to set.\nvalue: The value to set for the specified part of the component's state.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.gettime-interface","page":"Mermaid Interface","title":"Mermaid.gettime","text":"gettime(merInt::AbstractComponentIntegrator)\n\nGet the current time of the integrator.\n\nArguments\n\nint::AbstractComponentIntegrator: The integrator whose time is to be retrieved.\n\nReturns\n\nThe current time of the integrator.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.settime!-interface","page":"Mermaid Interface","title":"Mermaid.settime!","text":"settime!(merInt::AbstractComponentIntegrator, t)\n\nSet the current time of the integrator.\n\nArguments\n\nint::AbstractComponentIntegrator: The integrator whose time is to be set.\nt: The time to set.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Mermaid.ConnectedVariable-interface","page":"Mermaid Interface","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable <: AbstractConnectedVariable\n\nPoints to a variable within a component.\n\nFields\n\ncomponent::String: Name of the component.\nvariable::String: Name of the variable.\nvariableindex::Union{Nothing,Vector{Int},Int}: Index or range for the variable,   if applicable.\nduplicatedindex::Union{Nothing,Vector{Int},Int}: Index for duplicated   components, if applicable.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Mermaid.ConnectedVariable-Tuple{AbstractString}-interface","page":"Mermaid Interface","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable(name::AbstractString)\n\nConstruct a ConnectedVariable from a string name.\n\nArguments\n\nname::AbstractString: The full variable name.\n\nExamples\n\nConnectedVariable(\"comp.var\") ConnectedVariable(\"comp.var[1:5]\") where 1:5 is the variableindex ConnectedVariable(\"comp[2].var\") where 2 is the duplicatedindex ConnectedVariable(\"comp[1:3].var[4]\")\n\n\n\n\n\n","category":"method"},{"location":"examples/mtk/#ModelingToolkit-Integration","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Similarly to Mermaid, ModelingToolkit also allows specifying models as components and then connecting them together. However, the methods used are different. For an overview of these differences, you can see Is Mermaid right for me?. In summary, if it is possible to connect your components through ModelingToolkit, it is likely better to do that rather than through Mermaid. In order to simplify connected ModelingToolkit systems in Mermaid, you can create ModelingToolkitComponents for all of your ModelingToolkit models, and specify the connections through Mermaid. Mermaid will then figure out which ModelingToolkitComponents can be connected together in the MermaidProblem, perform the connections, generate the model and solve it.","category":"section"},{"location":"examples/mtk/#ModelingToolkitComponents","page":"ModelingToolkit Integration","title":"ModelingToolkitComponents","text":"TODO","category":"section"},{"location":"examples/external_components/#External-Components","page":"External Components","title":"External Components","text":"While there are many different modeling tools in Julia that can become components in Mermaid, some cases require libraries and packages from outside of the Julia ecosystem. In those cases, we may still be able to connect them to Mermaid as components. So long as the intergrator interface can still be defined, using PythonCall for example, then it can be connected within Mermaid.","category":"section"},{"location":"examples/surrogates/#Surrogates","page":"Surrogates","title":"Surrogates","text":"Sometimes, a model can be very expensive to solve. In other instances, we may be required to solve the same model many times, such as with Duplicated Components. In these instances, it can be useful to generate a surrogate machine learning model which approximates the output, and can do it faster than model solving.\n\nSurrogates of components can be generated in Mermaid. The component will train a surrogate to learn the step! function.","category":"section"},{"location":"examples/surrogates/#Building-a-surrogate-component","page":"Surrogates","title":"Building a surrogate component","text":"using OrdinaryDiffEq, Random, Mermaid, BenchmarkTools, Plots\nusing Surrogates\nusing CellMLToolkit\n\nRandom.seed!(0) # hide\nml = CellModel(\"ohara_rudy_cipa_v1_2017.cellml\")\n\ntspan = (0, 1000.0)\nlongtime = 100000.0\nn_samples = 1000\nprob = ODEProblem(ml, tspan)\nV = ml.sys.membrane₊v\nKi = ml.sys.intracellular_ions₊ki\n\n# Slightly perturb initial conditions\nprob[V] = -95.0\nprob[Ki] = 144.0\n\ncomp1 = DEComponent(prob, Tsit5();\n    name = \"cell\", timestep = 1000.0, state_names = Dict(\"v\" => V, \"ki\" => Ki),\n    intkwargs = (abstol = 1e-10, reltol = 1e-10, save_everystep = false, maxiters = Inf)\n)\n\nlb = prob.u0 - 0.01*abs.(prob.u0)\nub = prob.u0 + 0.01*abs.(prob.u0)\n\n# Create a surrogate component\nsurrogate_comp = SurrogateComponent(comp1, SecondOrderPolynomialSurrogate, lb, ub;\n    n_samples = n_samples)\n\nnothing # hide","category":"section"},{"location":"examples/surrogates/#Comparing-performance","page":"Surrogates","title":"Comparing performance","text":"Surrogates main use is to provide faster solutions to a model or simulation. However, faster performance is not guaranteed. Surrogates are frequently more performant but this should still be measured.\n\nIn this section, we will compare how our surrogate performs compared with solving the original ODE formulation.\n\n# Set up initial conditions for timing test\nalg = MinimumTimeStepper()\n\n# Benchmark the original component\nmp1 = MermaidProblem(components = [comp1], connectors = Connector[], tspan = (0,longtime))\nori_int = init(mp1, alg; save_vars = [\"cell.v\", \"cell.ki\"])\noriginal_time = @benchmark solve!(int) setup = (int = deepcopy(ori_int))\n\n# Benchmark the surrogate component\nmp2 = MermaidProblem(components = [surrogate_comp], connectors = Connector[], tspan = (0,longtime))\nsurr_int = init(mp2, alg; save_vars = [\"cell.v\", \"cell.ki\"])\nsurrogate_time = @benchmark solve!(int) setup = (int = deepcopy(surr_int))\n\nprintln(\"Original component minimum time: \", minimum(original_time.times) / 1e6, \" ms\")\nprintln(\"Surrogate component minimum time: \", minimum(surrogate_time.times) / 1e6, \" ms\")\nprintln(\"Speedup: \", minimum(original_time.times) / minimum(surrogate_time.times), \"x\")\nnothing # hide","category":"section"},{"location":"examples/surrogates/#Comparing-accuracy","page":"Surrogates","title":"Comparing accuracy","text":"Even if a surrogate model is performant, you should also verify its accuracy.\n\nIn this section, we will compare plots of both the original ODE component and the surrogate component for two variables. We also see how the true solution oscillates every 1000ms.\n\nsol = solve(prob; tspan = longtime, maxiters = Inf, saveat = 50, save_idxs = [V, Ki])\n\nsol1 = solve!(ori_int)\nsol2 = solve!(surr_int)\n\np1 = plot(sol.t, sol[V], label = \"True\", linewidth = 1)\np2 = plot(sol.t, sol[Ki], label = \"True\", linewidth = 1)\n\nplot!(p1, sol1.t, sol1[\"cell.v\"], label = \"Original\", linewidth = 3)\nplot!(p1, sol2.t, sol2[\"cell.v\"], label = \"Surrogate\", linestyle = :dash, linewidth = 3)\nxlabel!(p1, \"Time (ms)\")\nplot!(p2, sol1.t, sol1[\"cell.ki\"], label = \"Original\", linewidth = 3)\nplot!(p2, sol2.t, sol2[\"cell.ki\"], label = \"Surrogate\", linestyle = :dash, linewidth = 3)\nxlabel!(p2, \"Time (ms)\")\nylims!(p1, -88.005, -87.92)\nylims!(p2, 144.475, 144.675)\nylabel!(p1, \"Membrane Potential (mV)\")\nylabel!(p2, \"K+ Concentration (mM)\")\nfig = plot(p1, p2, layout = (1, 2), size = (800, 300), right_margin = 4Plots.mm,\n    bottom_margin = 5Plots.mm, left_margin = 3Plots.mm)\nsavefig(fig, \"surrogates_accuracy.png\") # hide\nnothing # hide\n\n(Image: The accuracy of the surrogate component)","category":"section"},{"location":"examples/out_of_sync/#Out-of-sync-computation","page":"Out of sync computation","title":"Out of sync computation","text":"So far, we have only seen a single one of Mermaids solvers, the MinimumTimeStepper. This solver is the simplest to understand, taking global time steps and solving all components up until the next step would put them ahead of the global time. This works fine for serial computations, but can lead to wasted resources if multiple cores are available. For example, if we have one component which doesn't have any inputs (but does have outputs), it could be solved entirely, and doesn't need to be kept in sync with the global time. This could be utilised to ensure all available cores are working (with most dedicated to solving the current global time step and the remainder can still be utilised by solving future time steps of this component).\n\nWe can do this in Mermaid with the QueueStepper. This solver creates a queue of all components which can be stepped, and assigns them to cores as they become available. After each component step has completed, we can find all components that depend on it and (assuming they aren't reliant on any other components/steps that need to run) add them to the queue.","category":"section"},{"location":"examples/out_of_sync/#Solving-with-out-of-sync-computations","page":"Out of sync computation","title":"Solving with out of sync computations","text":"TODO CFD flow informing Agents of enzymes, both informing a PDE of some chemical reactions","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Mermaid","page":"API","title":"Mermaid","text":"","category":"section"},{"location":"API/#Extensions","page":"API","title":"Extensions","text":"","category":"section"},{"location":"API/#Base.fullname-Tuple{Mermaid.AbstractConnectedVariable}","page":"API","title":"Base.fullname","text":"fullname(var::AbstractConnectedVariable)\n\nReturn the full name of a ConnectedVariable as a string.\n\nArguments\n\nvar::AbstractConnectedVariable: The connected variable to get the full name for.\n\nReturns\n\nString: The full name of the connected variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{Mermaid.AbstractMermaidSolution, AbstractString}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::AbstractMermaidSolution, var::AbstractString)\nBase.getindex(sol::AbstractMermaidSolution, var::AbstractConnectedVariable)\nBase.getindex(sol::AbstractMermaidSolution, index::Int)\n\nGet the solution for a variable var or at a time index index from a     MermaidSolution.\n\nArguments\n\nsol::AbstractMermaidSolution: The solution object.\nvar::Union{AbstractString, AbstractConnectedVariable}: The variable name.\nindex::Int: The time index of the variable.\n\nReturns\n\nIf var is provided, returns the MermaidSolution for that variable.\nIf index is provided, returns the MermaidSolution at time sol.t[index].\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.init","page":"API","title":"CommonSolve.init","text":"init(prob::MermaidProblem, alg::MermaidSolver; save_vars=[])\ninit(comp::AbstractComponent)\n\nInitialises an integrator (MermaidIntegrator or AbstractComponentIntegrator)     for the given MermaidProblem/AbstractComponent.\n\nArguments\n\nprob::MermaidProblem: The hybrid problem to be solved.\nalg::AbstractMermaidSolver: The AbstractMermaidSolver algorithm to be used for   solving the problem.\ncomp::AbstractComponent: The component to be initialised.\n\nKeyword Arguments\n\nsave_vars=[]: Which variables to save in the solution. Defaults to all non-special   variables.\n\nReturns\n\nMermaidIntegrator: The initialized integrator for the problem.\n\n\n\n\n\n","category":"function"},{"location":"API/#CommonSolve.init-Tuple{Mermaid.AbstractMermaidProblem, AbstractMermaidSolver}","page":"API","title":"CommonSolve.init","text":"init(prob::AbstractMermaidProblem, alg::AbstractMermaidSolver;\nsave_vars = nothing, saveat = nothing)\n\nDefines the integrator for a Mermaid hybrid simulation.\n\nArguments\n\nprob::AbstractMermaidProblem: The problem to be solved.\nalg::AbstractMermaidSolver: The Mermaid solver algorithm to be used.\nsave_vars: Variables to be saved during the simulation. Options include:\n:all: Save all variables.\n:none: Save no variables. Equivalent to an empty vector.\nVector{String}: A vector of connected variable names to save.\nnothing: Default. Save all non-special variables (i.e., variables that do not start with '#').\nsaveat::Function: When to save the variables during the simulation. Can be a function   that takes the integrator and current time and returns a boolean, or a vector of time   points at which to save, or a number representing the time interval (save at   tspan[1]:saveat:tspan[2]).\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.solve!-Tuple{Mermaid.AbstractMermaidIntegrator}","page":"API","title":"CommonSolve.solve!","text":"solve!(merInt::AbstractMermaidIntegrator)\n\nSolves the problem using the MermaidIntegrator. This handles all the message passing     and calls step! on the MermaidIntegrator.\n\nArguments\n\nmerInt::AbstractMermaidIntegrator: The integrator to be solved.\n\nReturns\n\nMermaidSolution: The solution of the problem.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.step!","page":"API","title":"CommonSolve.step!","text":"step!(int::AbstractMermaidIntegrator)\nstep!(int::AbstractComponentIntegrator)\n\nAdvance the state of the integrator int by one time step.\n\nArguments\n\nint::Union{AbstractMermaidIntegrator, AbstractComponentIntegrator}: The integrator to   advance.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.getstate","page":"API","title":"Mermaid.getstate","text":"getstate(comp::AbstractComponentIntegrator)\ngetstate(comp::AbstractComponentIntegrator, key)\n\nRetrieve the state of a component.\n\nArguments\n\ncomp::AbstractComponentIntegrator: The component whose state is to be retrieved.\nkey: The key specifying which part of the component's state to retrieve.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.gettime-Tuple{AbstractComponentIntegrator}","page":"API","title":"Mermaid.gettime","text":"gettime(merInt::AbstractComponentIntegrator)\n\nGet the current time of the integrator.\n\nArguments\n\nint::AbstractComponentIntegrator: The integrator whose time is to be retrieved.\n\nReturns\n\nThe current time of the integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.name-Tuple{AbstractComponent}","page":"API","title":"Mermaid.name","text":"name(int::AbstractComponentIntegrator)\nname(comp::AbstractComponent)\n\nGet the name of the integrator or component.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.runconnection!-Tuple{Mermaid.AbstractMermaidIntegrator, Mermaid.AbstractConnector}","page":"API","title":"Mermaid.runconnection!","text":"runconnection!(merInt::AbstractMermaidIntegrator, conn::AbstractConnector)\n\nExtract all the input states from merInt, apply the connection function, and set the output states in merInt.\n\nArguments\n\nmerInt::AbstractMermaidIntegrator: The Mermaid integrator containing the components.\nconn::AbstractConnector: The connector defining the connection.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.runconnection-Tuple{Mermaid.AbstractMermaidIntegrator, Mermaid.AbstractConnector}","page":"API","title":"Mermaid.runconnection","text":"runconnection(merInt::AbstractMermaidIntegrator, conn::AbstractConnector)\n\nExtract all the input states from merInt, apply the connection function, and return the output.\n\nArguments\n\nmerInt::AbstractMermaidIntegrator: The Mermaid integrator containing the components.\nconn::AbstractConnector: The connector defining the connection.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!","page":"API","title":"Mermaid.setstate!","text":"setstate!(comp::AbstractComponentIntegrator, state)\nsetstate!(comp::AbstractComponentIntegrator, key, value)\n\nSet the state of a component.\n\nArguments\n\ncomp::AbstractComponentIntegrator: The component whose state is to be set.\nstate: The new state to set for the entire component.\nkey: The key specifying which part of the component's state to set.\nvalue: The value to set for the specified part of the component's state.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.settime!-Tuple{AbstractComponentIntegrator, Any}","page":"API","title":"Mermaid.settime!","text":"settime!(merInt::AbstractComponentIntegrator, t)\n\nSet the current time of the integrator.\n\nArguments\n\nint::AbstractComponentIntegrator: The integrator whose time is to be set.\nt: The time to set.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.timestep-Tuple{AbstractComponent}","page":"API","title":"Mermaid.timestep","text":"timestep(int::AbstractComponent)\ntimestep(comp::AbstractComponentIntegrator)\n\nGet the proposed time step of the integrator or component. It can depend on the current     state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_solution!-Tuple{Mermaid.AbstractMermaidSolution, Mermaid.AbstractMermaidIntegrator}","page":"API","title":"Mermaid.update_solution!","text":"update_solution!(sol::MermaidSolution, merInt::MermaidIntegrator)\n\nUpdate the MermaidSolution sol with the current time and state from the     MermaidIntegrator.\n\nArguments\n\nsol::MermaidSolution: The MermaidSolution to be updated.\nmerInt::MermaidIntegrator: The integrator object providing the current time (currtime)   and states to access via getstate.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.variables","page":"API","title":"Mermaid.variables","text":"variables(comp::AbstractComponentIntegrator)\nvariables(comp::AbstractComponent)\n\nRetrieve the variable names of a component.\n\nArguments\n\ncomp::Union{AbstractComponent, AbstractComponentIntegrator}: The component (or component   integrator) whose variable names are to be retrieved.\n\nReturns\n\nA collection of variable names (as strings) associated with the component. This includes   all special variables such as #time and #model if applicable.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.variables-Tuple{AbstractComponentIntegrator}","page":"API","title":"Mermaid.variables","text":"variables(integrator::AbstractComponent)\nvariables(integrator::AbstractComponentIntegrator)\n\nGet the variables names of the component or integrator that can be accessed through getstate     and setstate!. This includes special variables like #time.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.AbstractComponent","page":"API","title":"Mermaid.AbstractComponent","text":"abstract type AbstractComponent\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractComponentIntegrator","page":"API","title":"Mermaid.AbstractComponentIntegrator","text":"abstract type AbstractComponentIntegrator\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractConnectedVariable","page":"API","title":"Mermaid.AbstractConnectedVariable","text":"abstract type AbstractConnectedVariable\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractConnector","page":"API","title":"Mermaid.AbstractConnector","text":"abstract type AbstractConnector\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractMermaidIntegrator","page":"API","title":"Mermaid.AbstractMermaidIntegrator","text":"abstract type AbstractMermaidIntegrator\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractMermaidProblem","page":"API","title":"Mermaid.AbstractMermaidProblem","text":"abstract type AbstractMermaidProblem\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractMermaidSolution","page":"API","title":"Mermaid.AbstractMermaidSolution","text":"abstract type AbstractMermaidSolution\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractMermaidSolution-Tuple{Real}","page":"API","title":"Mermaid.AbstractMermaidSolution","text":"(sol::MermaidSolution)(t::Real)\n\nInterpolates the solution at a given time t using linear interpolation.\n\nArguments\n\nsol::MermaidSolution: The solution object containing time points and state histories.\nt::Real: The time at which to interpolate the solution.\n\nReturns\n\nMermaidSolution: A new MermaidSolution object containing only that time and the   interpolated time and state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.AbstractMermaidSolver","page":"API","title":"Mermaid.AbstractMermaidSolver","text":"abstract type AbstractMermaidSolver\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractTimeDependentComponent","page":"API","title":"Mermaid.AbstractTimeDependentComponent","text":"abstract type AbstractTimeDependentComponent <: AbstractComponent\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AbstractTimeIndependentComponent","page":"API","title":"Mermaid.AbstractTimeIndependentComponent","text":"abstract type AbstractTimeIndependentComponent <: AbstractComponent\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable <: AbstractConnectedVariable\n\nPoints to a variable within a component.\n\nFields\n\ncomponent::String: Name of the component.\nvariable::String: Name of the variable.\nvariableindex::Union{Nothing,Vector{Int},Int}: Index or range for the variable,   if applicable.\nduplicatedindex::Union{Nothing,Vector{Int},Int}: Index for duplicated   components, if applicable.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable-Tuple{AbstractString}","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable(name::AbstractString)\n\nConstruct a ConnectedVariable from a string name.\n\nArguments\n\nname::AbstractString: The full variable name.\n\nExamples\n\nConnectedVariable(\"comp.var\") ConnectedVariable(\"comp.var[1:5]\") where 1:5 is the variableindex ConnectedVariable(\"comp[2].var\") where 2 is the duplicatedindex ConnectedVariable(\"comp[1:3].var[4]\")\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.Connector","page":"API","title":"Mermaid.Connector","text":"Connector <: AbstractConnector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{<:AbstractConnectedVariable}: Input variables for the connector.\noutputs::Vector{<:AbstractConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.Connector-Union{Tuple{}, Tuple{T}, Tuple{S}} where {S<:AbstractString, T<:AbstractString}","page":"API","title":"Mermaid.Connector","text":"Connector(inputs, outputs; func=nothing)\n\nConstruct a Connector from string names for inputs and outputs.\n\nArguments\n\ninputs::Vector{<:AbstractString}: Names of input variables.\noutputs::Vector{<:AbstractString}: Names of output variables.\n\nKeyword Arguments\n\nfunc: Function for mapping inputs to outputs. Defaults to nothing which passes a   single input, to all outputs.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.DuplicatedComponent","page":"API","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to     have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then   the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninit_states::Vector: Vector of states for the duplicated component, where each state   corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.DuplicatedComponent-Tuple{AbstractTimeDependentComponent, AbstractVector}","page":"API","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent(args...; kwargs...)\n\nDuplicate an existing component into a DuplicatedComponent.\n\nArguments\n\ncomponent::AbstractTimeDependentComponent: The component to be duplicated.\ninit_states::AbstractVector: A vector of initial states for the duplicated component.\n\nKeyword Arguments\n\ninstances::Union{Int, Nothing}: Number of instances of the component. If nothing, then   the number is variable and determined by the simulation. Defaults to nothing.\nname::AbstractString: Name of the duplicated component. Defaults to the original   component's name.\ntimestep::Real: Time step for the duplicated component. Defaults to the original   component's time step.\nstate_names: A dictionary mapping variable names (as strings) to their corresponding   variables in the original component. Defaults to the original component's state names.\ndefault_state: The default state to use when a new instance is created. Defaults to a   zero vector of the same length as the first initial state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MermaidProblem","page":"API","title":"Mermaid.MermaidProblem","text":"MermaidProblem <: AbstractMermaidProblem\nMermaidProblem(;\n    components::Vector{AbstractComponent},\n    connectors::Vector{AbstractConnector},\n    tspan::Tuple{Float64, Float64},\n    timescales::Vector{Float64}=ones(length(components)))\n\nDefines a Mermaid hybrid simulation problem.\n\nKeyword Arguments\n\ncomponents::Vector{<:AbstractComponent}: Vector of Components.\nconnectors::Vector{<:AbstractConnector}: Vector of Connector.\ntspan::Tuple{Float64, Float64}: The time span of the simulation.\ntimescales::Vector{Float64}=ones(length(components)): Timescales for each component.   Each component's timescale will be multiplied by the component's time to convert it to   the universal simulation time.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution{X, Y} <: AbstractMermaidSolution\n\nStores the solution of a MermaidProblem over time.\n\nFields\n\nt::X: Time points at which the solution is saved.\nu::Y: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution-Tuple{Mermaid.AbstractMermaidIntegrator}","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution(int::MermaidIntegrator) <: AbstractMermaidSolution\n\nCreate a MermaidSolution object initialized for the save_vars/variables in the     given MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to extract solution structure from.\n\nReturns\n\nMermaidSolution: A new MermaidSolution object with empty time and state arrays   for each variable to be saved.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MinimumTimeStepper","page":"API","title":"Mermaid.MinimumTimeStepper","text":"MinimumTimeStepper()\n\nA solver that steps the integrators in a MermaidIntegrator advancing to the next event.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.TimeIndependentComponent","page":"API","title":"Mermaid.TimeIndependentComponent","text":"TimeIndependentComponent(name::String, func::Function, initial_state)\n\nTimeIndependentComponent represents a component that does not evolve in time, but instead     computes its state based on its inputs, irregardless of the change in time.\n\nArguments\n\nname::String: The name of the component.\nfunc::Function: The function that computes the component's state based on its inputs. It   should take a single input of the same type as initial_state.\ninitial_state: The initial state of the component. This should be a valid input to   func.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AgentsComponent-Tuple{StandardABM}","page":"API","title":"Mermaid.AgentsComponent","text":"AgentsComponent(model::StandardABM; name=\"Agents Component\",\n                state_names=Dict{String,Any}(), timestep::Real=1.0)\n\nA Mermaid component that wraps an agent-based model (ABM) using the Agents.jl package.\n\nArguments\n\nmodel::StandardABM: The agent-based model to be solved.\n\nKeyword Arguments\n\nname::AbstractString: The name of the component. Defaults to \"Agents Component\".\nstate_names: A dictionary mapping variable names (as strings) to their corresponding   properties (agent properties or model properties) in the model. Defaults to an empty   dictionary.\ntimestep::Real: The time step for the component (not the ABM solver timestep), i.e. how   frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.DEComponent-Tuple{SciMLBase.AbstractDEProblem, Any}","page":"API","title":"Mermaid.DEComponent","text":"DEComponent(model::DiffEqBase.AbstractDEProblem, alg;\n            name::String=\"DE Component\", timestep::Float64=1.0, intkwargs::Tuple=(),\n            state_names::Dict{String,Any}=Dict{String,Any}())\nDEComponent(model::DiffEqBase.AbstractDEProblem; kwargs...)\n\nArguments\n\nmodel::DiffEqBase.AbstractDEProblem: SciML DE problem (e.g., ODEProblem, etc.)\nalg: Algorithm from DifferentialEquations.jl to be used   for solving the DEProblem. If no algorithm is provided, the algorithm will be   automatically chosen by DifferentialEquations.jl.\n\nKeyword Arguments\n\nname::AbstractString: Name of the component. Defaults to \"DE Component\".\ntimestep::Real: Time step for the component. Defaults to 1.0.\nintkwargs: Additional keyword arguments for the DE solver. Defaults to no keywords.\nstate_names: Dictionary mapping variable names (as strings) to their corresponding   indices in the state vector or symbols from Symbolics.jl. Defaults to an empty   dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MOLComponent-Tuple{SciMLBase.AbstractDEProblem, SciMLBase.AbstractDEAlgorithm}","page":"API","title":"Mermaid.MOLComponent","text":"MOLComponent(model::DiffEqBase.AbstractDEProblem, alg::DiffEqBase.AbstractDEAlgorithm;\n             name::String=\"MOL Component\", timestep::Real=1.0, intkwargs::Tuple=(),\n             state_names::Dict{String,Any}=Dict{String,Any}())\n\nArguments\n\nmodel::DiffEqBase.AbstractDEProblem: SciML DE problem (e.g., ODEProblem, etc.)\nalg::DiffEqBase.AbstractDEAlgorithm: Algorithm from DifferentialEquations.jl to be used   for solving the DEProblem.\n\nKeyword Arguments\n\nname::AbstractString: Name of the component. Defaults to \"MOL Component\".\ntimestep::Real: Time step for the component. Defaults to 1.0.\nintkwargs: Additional keyword arguments for the DE solver. Defaults to no keywords.\nstate_names: Dictionary mapping variable names (as strings) to their corresponding   indices in the state vector or symbols from Symbolics.jl. Defaults to an empty   dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.SurrogateComponent-Tuple{AbstractTimeDependentComponent, Any, Any, Any}","page":"API","title":"Mermaid.SurrogateComponent","text":"SurrogateComponent(args...; kwargs...)\n\nRepresents a component that is replaced with a surrogate in the simulation, speeding up computation of a complex step! function.\n\nArguments\n\ncomponent::AbstractTimeDependentComponent: The original component to be replaced with a surrogate.\nsurrogate: The surrogate model or method to use for the component.\nlower_bound: Lower bounds for each state variable for surrogate sampling.\nupper_bound: Upper bounds for each state variable for surrogate sampling.\n\nKeyword Arguments\n\nname::AbstractString: Name of the component. Defaults to the same as the original component.\ntimestep::Real: Time step for the component. Defaults to the same as the original component.\nmodel: A Flux.jl model to use as the surrogate. If nothing, a default feedforward neural network is created.\nstate_names: Dictionary mapping variable names (as strings) to their corresponding indices in the   state vector or symbols from ModelingToolkit/Symbolics. Defaults to the same as the original component.\nn_samples::Integer: Number of samples to use for training the surrogate. Defaults to 1000.\nn_epochs::Integer: Number of training epochs for the surrogate. Defaults to 1000.\n\n\n\n\n\n","category":"method"},{"location":"#Mermaid.jl","page":"Introduction","title":"Mermaid.jl","text":"","category":"section"},{"location":"#Summary-/-README","page":"Introduction","title":"Summary / README","text":"","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"Mermaid can be installed from Julia with:\n\nusing Pkg; Pkg.add(\"Mermaid\")","category":"section"},{"location":"#FAQ","page":"Introduction","title":"FAQ","text":"Q: How can I use Mermaid to run a hybrid model simulation?\n\nA: Check out the Tutorial, it covers how to set up and run a hybrid simualtion between an Agent-based model and an ODE system.\n\nQ: What if Mermaid doesn't have a component for the type of model I want to use?\n\nA: Check out the Mermaid Interface, you can easily define new components for many different simulation tools.\n\nQ: The Tutorial didn't cover what I wanted. Where can I view more examples?\n\nA: In the Examples section of course. We have examples showing all of the more advanced features of Mermaid including:\n\nduplicated components,\nout of sync computation,\nexternal (non-Julia) components,\nsurrogate model approximations,\nmapping between spatial components on different resolutions,\nintegration with ModelingToolkit.jl.\n\nQ: Is Mermaid the right tool for me?\n\nA: That depends on what type of hybrid simulation you are looking to run. Luckily, you can check out Is Mermaid right for me? and find out.","category":"section"},{"location":"#Mermaid.Mermaid","page":"Introduction","title":"Mermaid.Mermaid","text":"Mermaid.jl\n\n(Image: Mermaid.jl) (Image: Run tests) (Image: codecov)\n\nMermaid.jl is a hybrid and multiscale simulation enviroment in Julia.\n\nComplex simulations can be produced by connecting together components from a wide range of Julia modeling tools.\n\nIts key features are:\n\nIt is particularly well suited towards hybrid (continuous and discrete time), multiscale and nested systems. With direct support for nesting models within other models (Agent-based models where each agent solves an ODE, for example).\nModels can be specified as arbitrary Julia code, include calls to other programming languages such as C or Python.\nOut-of-the-box support for Agents.jl, DifferentialEquations.jl (and related packages), Surrogates.jl, and MethodOfLines.jl.\nA simple integrator interface allows extensions to previously unsupported components.\n\n\n\n\n\n","category":"module"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will:\n\nCreate a hybrid simulation between an Agent-based model, defined in Agents.jl, and an ODE system defined through DifferentialEquations.jl.\nIntroduce Mermaid Components for Agents.jl and DifferentialEquations.jl.\nDemonstrate how these Components can be connected together through Connectors.\nSolve the hybrid model.\nVisualise the results of the simulation.\n\nThe example system we will use for this will be a model of a forest fire (governed by an Agent-based model), with the growth of each tree informed by an ODE model.","category":"section"},{"location":"tutorial/#Components","page":"Tutorial","title":"Components","text":"To begin, we need to define our components. These will be an ODE model component for each tree, and an Agent-based model component for handling the forest level properties (in this case, the spread of heat/fire).","category":"section"},{"location":"tutorial/#ODE-Components","page":"Tutorial","title":"ODE Components","text":"To define the ODE model, let's have a look at how to define an ODE Component.\n\nWe see that we need to define an ODEProblem to use in the component, so let's create one.\n\nusing OrdinaryDiffEq\nfunction tree!(du, u, p, t)\n    heat, life = u\n    du[1] = 0\n    du[2] = (life*(1-life/10.0)-heat*life)/10\nend\nu0 = [4.0, 2.0]\ntspan = (0.0, 150.0)\nprob = ODEProblem(tree!, u0, tspan)\n\nnothing #hide\n\nNext, we want to wrap this ODEProblem inside an DEComponent. For this, we will need to define the state_names field, and should generally provide a value for the name field (since component names in a hybrid simulation should be unique).\n\nusing Mermaid\ncomp1 = DEComponent(prob, Rodas5();\n    name=\"tree\", state_names=Dict(\"heat\" => 1, \"life\" => 2),\n)\n\nnothing #hide","category":"section"},{"location":"tutorial/#Duplicated-Components","page":"Tutorial","title":"Duplicated Components","text":"Since the ODEProblem is defined for only a single tree, we can efficiently simulate time ODE system many times by generating a duplicated component. This component stores a single ODEProblem that it will solve across many different states. In this case, we can have a state for each tree in the Agent-based model. Let's have a look at how to define a DuplicatedComponent.\n\ndup_comp = DuplicatedComponent(comp1, [copy(u0) for _ in 1:640];\n    instances=640,\n)\n\nnothing #hide","category":"section"},{"location":"tutorial/#Agents.jl-Components","page":"Tutorial","title":"Agents.jl Components","text":"Now that we have created our DEComponent, we can move on to the AgentsComponent, so let's have a look at its documentation.\n\nWe can see that, again, we need to define the model (this time a StandardABM from Agents.jl), a name and a state_names.\n\nusing Agents, Random, Statistics\n@agent struct Tree(GridAgent{2})\n    heat::Float64 # Heat is averaged across neighbors, passed to ODE model\n    life::Float64 # Life is informed by ODE model\nend\n\nfunction forest_fire(; density=0.4, griddims=(40, 40), seed=2)\n    space = GridSpaceSingle(griddims; periodic=false, metric=:chebyshev)\n    rng = Random.MersenneTwister(seed)\n    forest = StandardABM(Tree, space; rng, agent_step! = tree_step!)\n    for _ in 1:floor(density * prod(griddims))\n        # Randomly place trees in the grid\n        add_agent_single!(forest; heat=rand(), life=rand())\n    end\n    return forest\nend\n\nfunction tree_step!(tree, forest)\n    nearbyheat = mean([getproperty(neighbor, :heat) for neighbor in nearby_agents(tree, forest, 1)])\n    if isnan(nearbyheat)\n        nearbyheat = 0.0\n    end\n    tree.heat = tree.heat * 0.9 + nearbyheat * 0.1\n    if rand(abmrng(forest)) < 1e-4 # Random chance of fire\n        tree.heat = 10.0\n    end\n    # Simulate tree life cycle\n    if tree.heat > 1.0 && tree.life > 1.0\n        # Tree on fire\n        tree.heat += 1.0\n    else\n        # Tree not on fire so heat disappates\n        tree.heat -= 0.05\n    end\n    if tree.heat < 0.0\n        tree.heat = 0.0\n    end\nend\n\nforest = forest_fire()\n\ncomp2 = AgentsComponent(forest;\n    name=\"forest\", state_names=Dict(\"heat\" => :heat, \"life\" => :life)\n)","category":"section"},{"location":"tutorial/#Connections","page":"Tutorial","title":"Connections","text":"We can now set up the connections between the variables in the two components.\n\nThe format for specifying a ConnectedVariable is given in Mermaid Interface, but in short, it is a string containing a component name and a variable/state name. It can also contain optional indices for only accessing part of a variable (given at the end of the ConnectedVariable), or for only accessing some subcomponents, such as for DuplicatedComponents (given at the end of the component name).\n\nconn1 = Connector(inputs=[\"forest.heat[1:640]\"], outputs=[\"tree[1:640].heat\"])\nconn2 = Connector(inputs=[\"tree[1:640].life\"], outputs=[\"forest.life[1:640]\"])","category":"section"},{"location":"tutorial/#Solving-the-hybrid-model","page":"Tutorial","title":"Solving the hybrid model","text":"To create the hybrid model, we need to create a MermaidProblem. We can then solve this using the CommonSolve interface.\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2], tspan=tspan)\nalg = MinimumTimeStepper()\nsol = solve(mp, alg)","category":"section"},{"location":"tutorial/#Plotting-the-solution","page":"Tutorial","title":"Plotting the solution","text":"After running solve, we get sol, a MermaidSolution instance. This stores all variables given in state_names at each timepoint.\n\nusing Plots\n\nplot(sol.t, sol[\"forest.life[1]\"], color=:green, label=\"Life\")\nplot!(sol.t, sol[\"forest.heat[1]\"], color=:red, label=\"Heat\")\n\nnothing # hide","category":"section"},{"location":"tutorial/#Advanced-Visualisations","page":"Tutorial","title":"Advanced Visualisations","text":"While we can plot the variables from the ODE component easily, the Agent-based model is a bit more challenging. But default, we only store the variables given in state_names in the solution. This can be changed by providing save_vars=[\"forest.#model\"] to solve, in which case the full Agent-based model state will be visable in the solution at all timepoints.\n\ntip: #model and Special Variables\n\"#model\" is a special variable for AgentsComponents. Special variables, denoted by starting with # are not saved by default but can be used with connectors, getstate, setstate!, or save_vars. To view the special variables of a component, you can call variables(component).\n\nHowever, this can be wasteful if we know we only want an animation of the model (which can be generated during simulation). We will set up a Connector which takes an input of the model's current state, and instead of a transformation, we will use a function which adds the current state to a video.\n\nusing Makie\nusing CairoMakie\n\ngroupcolor(tree) = tree.heat > 1 ? :red : :green\ngroupmarker(a) = a.life > 1 ? :utriangle : :circle\nfig, ax = abmplot(forest; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\nio = VideoStream(fig)\nfunction plot_input(model)\n    empty!(ax)\n    abmplot!(ax, model; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\n    recordframe!(io)\nend\n\nconn3 = Connector(\n    inputs=[\"forest.#model\"],\n    outputs=Vector{String}(),\n    func=(model) -> plot_input(model)\n)\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2, conn3], tspan=tspan)\nsol = solve(mp, alg)\n\nsave(\"forest_fire.mp4\", io)\n\nnothing #hide\n\n(Image: An animation of the forest fire simulation)","category":"section"},{"location":"tutorial/#Mermaid.DEComponent-tutorial","page":"Tutorial","title":"Mermaid.DEComponent","text":"DEComponent(model::DiffEqBase.AbstractDEProblem, alg;\n            name::String=\"DE Component\", timestep::Float64=1.0, intkwargs::Tuple=(),\n            state_names::Dict{String,Any}=Dict{String,Any}())\nDEComponent(model::DiffEqBase.AbstractDEProblem; kwargs...)\n\nArguments\n\nmodel::DiffEqBase.AbstractDEProblem: SciML DE problem (e.g., ODEProblem, etc.)\nalg: Algorithm from DifferentialEquations.jl to be used   for solving the DEProblem. If no algorithm is provided, the algorithm will be   automatically chosen by DifferentialEquations.jl.\n\nKeyword Arguments\n\nname::AbstractString: Name of the component. Defaults to \"DE Component\".\ntimestep::Real: Time step for the component. Defaults to 1.0.\nintkwargs: Additional keyword arguments for the DE solver. Defaults to no keywords.\nstate_names: Dictionary mapping variable names (as strings) to their corresponding   indices in the state vector or symbols from Symbolics.jl. Defaults to an empty   dictionary.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Mermaid.DuplicatedComponent-tutorial","page":"Tutorial","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to     have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then   the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninit_states::Vector: Vector of states for the duplicated component, where each state   corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Mermaid.AgentsComponent-tutorial","page":"Tutorial","title":"Mermaid.AgentsComponent","text":"AgentsComponent(model::StandardABM; name=\"Agents Component\",\n                state_names=Dict{String,Any}(), timestep::Real=1.0)\n\nA Mermaid component that wraps an agent-based model (ABM) using the Agents.jl package.\n\nArguments\n\nmodel::StandardABM: The agent-based model to be solved.\n\nKeyword Arguments\n\nname::AbstractString: The name of the component. Defaults to \"Agents Component\".\nstate_names: A dictionary mapping variable names (as strings) to their corresponding   properties (agent properties or model properties) in the model. Defaults to an empty   dictionary.\ntimestep::Real: The time step for the component (not the ABM solver timestep), i.e. how   frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Mermaid.Connector-tutorial","page":"Tutorial","title":"Mermaid.Connector","text":"Connector <: AbstractConnector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{<:AbstractConnectedVariable}: Input variables for the connector.\noutputs::Vector{<:AbstractConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Mermaid.MermaidProblem-tutorial","page":"Tutorial","title":"Mermaid.MermaidProblem","text":"MermaidProblem <: AbstractMermaidProblem\nMermaidProblem(;\n    components::Vector{AbstractComponent},\n    connectors::Vector{AbstractConnector},\n    tspan::Tuple{Float64, Float64},\n    timescales::Vector{Float64}=ones(length(components)))\n\nDefines a Mermaid hybrid simulation problem.\n\nKeyword Arguments\n\ncomponents::Vector{<:AbstractComponent}: Vector of Components.\nconnectors::Vector{<:AbstractConnector}: Vector of Connector.\ntspan::Tuple{Float64, Float64}: The time span of the simulation.\ntimescales::Vector{Float64}=ones(length(components)): Timescales for each component.   Each component's timescale will be multiplied by the component's time to convert it to   the universal simulation time.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Mermaid.MermaidSolution-tutorial","page":"Tutorial","title":"Mermaid.MermaidSolution","text":"MermaidSolution{X, Y} <: AbstractMermaidSolution\n\nStores the solution of a MermaidProblem over time.\n\nFields\n\nt::X: Time points at which the solution is saved.\nu::Y: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"}]
}
