var documenterSearchIndex = {"docs":
[{"location":"is_mermaid_right_for_me/#Is-Mermaid-right-for-me?","page":"Is Mermaid right for me?","title":"Is Mermaid right for me?","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Comparison-to-other-software","page":"Is Mermaid right for me?","title":"Comparison to other software","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#ModelingToolkit.jl","page":"Is Mermaid right for me?","title":"ModelingToolkit.jl","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Modia.jl?","page":"Is Mermaid right for me?","title":"Modia.jl?","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Causal.jl","page":"Is Mermaid right for me?","title":"Causal.jl","text":"","category":"section"},{"location":"examples/duplicated_components/#Advanced-Duplicated-Components","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"","category":"section"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"You may have seen us use duplicated components in the Tutorial. This is a very powerful tool that lets you efficiently create many instances of a component integrator, each with their own independent state that can be stepped independently. In the Tutorial, we used duplicated components to create lots of instances of the tree ODE model, so every tree could be tracked independently. Rather than creating 640 components, each with its own integrator - we create 640 state vectors, reducing the memory requirements for the duplicated component.","category":"page"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"However, while this functionality is useful, it is not always possible to specify the number of instances a priori. For this reason, it is also possible to create duplicated components with a variable number of instances.","category":"page"},{"location":"examples/duplicated_components/#Setup","page":"Advanced Duplicated Components","title":"Setup","text":"","category":"section"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"For this example, we are going to create an agent-based model of a cell population with each cell goverened by a simple growth model tracking protein mass which is dependent on a spatial nutrient distribution and the number of nearby cells.","category":"page"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"using DifferentialEquations, Agents, Random, Mermaid, CairoMakie\nusing LinearAlgebra: norm\nRandom.seed!(1) # hide\n\nfunction cell!(du, u, p, t)\n    nutrients = u[1]\n    du[1] = 0\n    uptake = 2 * nutrients / (1 + nutrients)\n    decay = 0.1 * (1+u[2]/10)\n    du[2] = uptake - decay\nend\n\nu0 = [1.0, 1.0]\ntspan = (0.0, 250.0)\nprob = ODEProblem(cell!, u0, tspan)\nusing Mermaid\ncomp1 = ODEComponent(\n    model=prob,\n    name=\"cell\",\n    state_names=Dict(\"nutrients\" => 1, \"mass\" => 2),\n)\n\n@agent struct Cell(ContinuousAgent{2,Float64})\n    mass::Float64 # Cell mass is informed by ODE model\n    nutrients::Float64 # Local nutrient availability\nend\n\nfunction colony(; n_cells=3, n_nodes=5, griddims=(40, 40), seed=2)\n    space = ContinuousSpace(griddims; periodic=true)\n    rng = Random.MersenneTwister(seed)\n    nodes = [rand(2) .* griddims for _ in 1:n_nodes]\n    colony = StandardABM(Cell, space; rng, (agent_step!)=cell_step!, properties=Dict(:nodes => nodes))\n    for _ in 1:n_cells\n        vel = rand(2) .- 0.5\n        mass = rand()\n        nutrients = rand()\n        add_agent!(colony, vel, 1, 1)\n    end\n    return colony\nend\n\nfunction wrap_periodic(pos, dims)\n    return SVector{length(pos)}(mod.(pos, dims))\nend\n\nfunction periodic_distance(a, b, dims)\n    # Computes minimum image distance between points a and b in periodic box of size dims\n    d = abs.(a .- b)\n    return norm(min.(d, dims .- d))\nend\n\nfunction nutrients(pos, colony)\n    nutrients = 0.0\n    spread = 7.0\n    dims = abmspace(colony).extent\n    for node in colony.nodes\n        # Calculate periodic distance to node\n        dist = periodic_distance(node, pos, dims)\n        nutrients += exp(-dist^2 / spread^2)/2 # Gaussian decay\n    end\n    return nutrients\nend\n\nfunction cell_step!(cell, colony)\n    # Move away from nearby agents\n    speed = 0.5\n    for cell2 in nearby_agents(cell, colony, 0.5)\n        cell.vel -= speed * (cell2.pos - cell.pos) / norm(cell2.pos - cell.pos)^2\n    end\n    # Max speed\n    if norm(cell.vel) > speed\n        cell.vel = speed * cell.vel / norm(cell.vel)\n    end\n    # Walk and apply chemotaxis\n    oldnutrients = nutrients(cell.pos, colony)\n    walk!(cell, cell.vel, colony)\n    newnutrients = nutrients(cell.pos, colony)\n    if newnutrients < oldnutrients\n        # If nutrients decrease, random direction on next iteration\n        cell.vel += rand(2) .- 0.5\n    end\n    # Update nutrients and mass\n    cell.nutrients = nutrients(cell.pos, colony)/(length(collect(nearby_ids(cell, colony, 0.5)))+1)\n    # If large mass, split into two\n    splitmass = 15\n    if cell.mass > splitmass\n        dims = abmspace(colony).extent\n        for m in (splitmass/2, cell.mass - splitmass/2)\n            new_pos = wrap_periodic(cell.pos + rand(2) .- 0.5, dims)\n            add_agent!(new_pos, colony; vel=cell.vel, mass=m, nutrients=0)\n        end\n        remove_agent!(cell, colony)\n    end\n    if cell.mass < 0\n        remove_agent!(cell, colony)\n    end\nend\n\npop = colony()\n\ncomp2 = AgentsComponent(\n    model=pop,\n    name=\"colony\",\n    state_names=Dict(\"mass\" => :mass, \"nutrients\" => :nutrients)\n)\n\nconn1 = Connector(inputs=[\"colony.nutrients\"], outputs=[\"cell.nutrients\"])\nconn2 = Connector(inputs=[\"cell.mass\"], outputs=[\"colony.mass\"])\n\nnothing # hide","category":"page"},{"location":"examples/duplicated_components/#Flexible-Duplicated-Components","page":"Advanced Duplicated Components","title":"Flexible Duplicated Components","text":"","category":"section"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"If we don't provide any value for the instances field when creating the duplicated component, it will be created as a flexible duplicated component, letting a special input called #ids give the indexes of the current states (any indexes not specified in #ids are removed, and any state indexes specified in #ids that are not current states are created). Some components, like AgentComponents, already have pre-made special outputs for the #ids which we can use to couple duplicated components to an Agent-based model.","category":"page"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"dup_comp = DuplicatedComponent(\n    component=comp1,\n    initial_states=[],\n    default_state=u0,\n)\nconn3 = Connector(inputs=[\"colony.#ids\"], outputs=[\"cell.#ids\"])\n\nnothing # hide","category":"page"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"note: Sorting of Connectors\nYou may wonder about the order that connectors are applied. If we adjusted the IDs after applying conn2, we would be using an old value for IDs. Generally, we utilise the order specified in the MermaidProblem. However, special variable outputs (variables beginning with \"#\") are an exception to this rule and are always applied first.","category":"page"},{"location":"examples/duplicated_components/#Solving-and-visualisation","page":"Advanced Duplicated Components","title":"Solving and visualisation","text":"","category":"section"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"function make_nutrient_heatarray(colony; gridsize=(40, 40))\n    arr = zeros(Float64, gridsize...)\n    xs = range(0, stop=abmspace(colony).extent[1], length=gridsize[1])\n    ys = range(0, stop=abmspace(colony).extent[2], length=gridsize[2])\n    for (i, x) in enumerate(xs), (j, y) in enumerate(ys)\n        arr[i, j] = nutrients(SVector(x, y), colony)\n    end\n    return arr\nend\n\nfig, ax = abmplot(pop; agent_color=:black, agent_marker=:circle, agent_size=x->x.mass+3,\n    heatarray=make_nutrient_heatarray, heatkwargs=(colormap=:Greens_5,))\nio = VideoStream(fig; framerate=10)\nfunction plot_input(model)\n    empty!(ax)\n    abmplot!(ax, model; agent_color=:black, agent_marker=:circle, agent_size=x -> x.mass + 3,\n        heatarray=make_nutrient_heatarray, heatkwargs=(colormap=:Greens_5,))\n    ax.title = \"Time: $(round(abmtime(model))), Population: $(nagents(model))\"\n    recordframe!(io)\nend\n\nconn4 = Connector(\n    inputs=[\"colony.#model\"],\n    outputs=Vector{String}(),\n    func=(model) -> plot_input(model)\n)\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2, conn3, conn4], max_t=tspan[2])\nalg = MinimumTimeStepper()\nsol = solve(mp, alg)\n\nsave(\"cell_colony.mp4\", io)\n\nnothing # hide","category":"page"},{"location":"examples/duplicated_components/","page":"Advanced Duplicated Components","title":"Advanced Duplicated Components","text":"(Image: An animation of the cell colony simulation)","category":"page"},{"location":"examples/spatial_maps/#Spatial-maps","page":"Spatial maps","title":"Spatial maps","text":"","category":"section"},{"location":"examples/spatial_maps/","page":"Spatial maps","title":"Spatial maps","text":"When connecting multiple spatial models, we may be required to define a mapping function from the coordinate system of 1 component to another. For example, a PDE component is solved through MethodOfLines which will have some specified discretization, but a connected Agent-based model may have continuous positions, or discrete positions on a different resolution. We provide a handful of tools for mapping between two different spaces.","category":"page"},{"location":"examples/spatial_maps/","page":"Spatial maps","title":"Spatial maps","text":"TODO","category":"page"},{"location":"interface/#Mermaid-Interface","page":"Mermaid Interface","title":"Mermaid Interface","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"In this section, we will:","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"See the integrator interface that Mermaid uses,\nFind out how this fits with CommonSolve,\nLook at how the AgentsComponent is defined, as an example.","category":"page"},{"location":"interface/#Interface-requirements","page":"Mermaid Interface","title":"Interface requirements","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The interface used is Mermaid is compatible with, and uses, the SciML CommonSolve interface. In particular, each Component is some immutable problem type that stores required data to solve a Component (for example, an ODEProblem). We then also have an Integrator for each Component which stores the current state and handles solving over time.","category":"page"},{"location":"interface/#Component","page":"Mermaid Interface","title":"Component","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"There are two categories of Components in Mermaid. AbstractTimeDependentComponents and AbstractTimeIndependentComponents, both of which are AbstractComponents.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"A component must contain the following fields:","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"name which is a subtype of AbstractString,\ntime_step which is a Float64,\nstate_names which is a Dict which maps from variable names in the form of a String (variable name format) to some other object (typically a numerical index or symbol) which can be used to identify that variable internally.","category":"page"},{"location":"interface/#Integrator","page":"Mermaid Interface","title":"Integrator","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"A ComponentIntegrator is a mutable struct which can be freely modified over a simulation, since it will be typically discarded at the end. It typically only stores the current state of that component, and has some associated functions for handling this state.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"In addition to having some functions defined on the integrator, we also have some required fields.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"outputs and inputs are Dicts for mapping from a ConnectedVariable to its current value. The values in these Dicts are set by Mermaid but the initial creation of this Dict (in particular, its keys) need to be defined in the init function. The values from inputs should be used to set the state during the step! function.\nThe original Component should also be stored under the field name component. This allows access to any problem settings, or other fields like the name.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"todo: setstate! and inputs\nCouldn't the state be set by mermaid, rather than in the step function?","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"warning: Warning\nAn Integrator is required for all Components, even TimeIndependentComponents. They just store the state that they were last called with.","category":"page"},{"location":"interface/#Functions","page":"Mermaid Interface","title":"Functions","text":"","category":"section"},{"location":"interface/#step!","page":"Mermaid Interface","title":"step!","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The step! function should advance the ComponentIntegrator (its only input) one time step (defined by Component.time_step). This should also include reading the inputs field and updating the integrators internal state accordingly.","category":"page"},{"location":"interface/#init","page":"Mermaid Interface","title":"init","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The init function takes as inputs a Component and a Vector{Connector} and returns the corresponding ComponentIntegrator. This includes the process of creating the inputs and outputs Dicts which require the keys to be specified, i.e. the init function should read through the Vector{Connector} and look for any outputs or inputs into this component, and add the ConnectedVariables as keys to the inputs and outputs Dicts.","category":"page"},{"location":"interface/#getstate-and-setstate!","page":"Mermaid Interface","title":"getstate and setstate!","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The function getstate function reads the state of a ComponentIntegrator at a given ConnectedVariable and returns it. The setstate! function similarly mutates the current state of the ComponentIntegrator to assign an inputted value to the ConnectedVariable.","category":"page"},{"location":"interface/#gettime","page":"Mermaid Interface","title":"gettime","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"Simply returns the current simulated time of a ComponentIntegrator.","category":"page"},{"location":"interface/#AgentsComponent-Example","page":"Mermaid Interface","title":"AgentsComponent Example","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"todo: Code example\nWe should include the code of the Agents component here too. probably with literate","category":"page"},{"location":"interface/#Mermaid.AgentsComponent-interface","page":"Mermaid Interface","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Mermaid.AgentsComponentIntegrator-interface","page":"Mermaid Interface","title":"Mermaid.AgentsComponentIntegrator","text":"AgentsComponentIntegrator <: ComponentIntegrator\n\nA mutable struct that integrates an AgentsComponent using the Agents.jl package.\n\nFields\n\nintegrator::StandardABM: The agent-based model integrator.\ncomponent::AgentsComponent: The AgentsComponent being integrated.\noutputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"type"},{"location":"interface/#CommonSolve.step!-Tuple{Mermaid.AgentsComponentIntegrator}-interface","page":"Mermaid Interface","title":"CommonSolve.step!","text":"step!(compInt::AgentsComponentIntegrator)\n\nSets the state based on the current inputs and steps the AgentsComponentIntegrator in time one step.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be stepped. Its internal state will be mutated.\n\n\n\n\n\n","category":"method"},{"location":"interface/#CommonSolve.init-Tuple{AgentsComponent, Vector{Connector}}-interface","page":"Mermaid Interface","title":"CommonSolve.init","text":"init(c::AgentsComponent, conns::Vector{Connector})\n\nInitializes an AgentsComponentIntegrator for the given AgentsComponent and its connections.\n\nArguments\n\nc::AgentsComponent: The AgentsComponent to be integrated.\nconns::Vector{Connector}: The Connectors that define the inputs and outputs of the component.\n\nReturns\n\nAgentsComponentIntegrator: The initialized integrator for the Agents.jl component.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.getstate-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable}-interface","page":"Mermaid Interface","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator, key::ConnectedVariable)\n\nRetrieves the state of a specific variable from the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to retrieve.\n\nReturns\n\nThe current state of the variable specified by key, which can be a model-level property or an agent-specific property.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable, Any}-interface","page":"Mermaid Interface","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, key::ConnectedVariable, value)\n\nSets the state of a specific variable in the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to set.\nvalue: The value to assign to the specified variable's state.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.gettime-Tuple{Mermaid.AgentsComponentIntegrator}-interface","page":"Mermaid Interface","title":"Mermaid.gettime","text":"gettime(compInt::AgentsComponentIntegrator)\n\nReturns the simulation time of the AgentsComponentIntegrator at the current state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current time.\n\nReturns\n\ntime: The current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Variable-Names","page":"Mermaid Interface","title":"Variable Names","text":"","category":"section"},{"location":"examples/mtk/#ModelingToolkit-Integration","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"","category":"section"},{"location":"examples/mtk/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Similarly to Mermaid, ModelingToolkit also allows specifying models as components and then connecting them together. However, the methods used are different. For an overview of these differences, you can see Is Mermaid right for me?. In summary, if it is possible to connect your components through ModelingToolkit, it is likely better to do that rather than through Mermaid. In order to simplify connected ModelingToolkit systems in Mermaid, you can create ModelingToolkitComponents for all of your ModelingToolkit models, and specify the connections through Mermaid. Mermaid will then figure out which ModelingToolkitComponents can be connected together in the MermaidProblem, perform the connections, generate the model and solve it.","category":"page"},{"location":"examples/mtk/#ModelingToolkitComponents","page":"ModelingToolkit Integration","title":"ModelingToolkitComponents","text":"","category":"section"},{"location":"examples/mtk/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"TODO","category":"page"},{"location":"examples/external_components/#External-Components","page":"External Components","title":"External Components","text":"","category":"section"},{"location":"examples/external_components/","page":"External Components","title":"External Components","text":"While there are many different modeling tools in Julia that can become components in Mermaid, some cases require libraries and packages from outside of the Julia ecosystem. In those cases, we may still be able to connect them to Mermaid as components. So long as the intergrator interface can still be defined, using PythonCall for example, then it can be connected within Mermaid.","category":"page"},{"location":"examples/surrogates/#Surrogates","page":"Surrogates","title":"Surrogates","text":"","category":"section"},{"location":"examples/surrogates/","page":"Surrogates","title":"Surrogates","text":"Sometimes, a model can be very expensive to solve. In other instances, we may be required to solve the same model many times, such as with Duplicated Components. In these instances, it can be useful to generate a surrogate machine learning model which approximates the output, and can do it faster than model solving.","category":"page"},{"location":"examples/surrogates/","page":"Surrogates","title":"Surrogates","text":"Surrogates of components can be generated in Mermaid. The component will train a surrogate to learn the step! function.","category":"page"},{"location":"examples/out_of_sync/#Out-of-sync-computation","page":"Out of sync computation","title":"Out of sync computation","text":"","category":"section"},{"location":"examples/out_of_sync/","page":"Out of sync computation","title":"Out of sync computation","text":"So far, we have only seen a single one of Mermaids solvers, the MinimumTimeStepper. This solver is the simplest to understand, taking global time steps and solving all components up until the next step would put them ahead of the global time. This works fine for serial computations, but can lead to wasted resources if multiple cores are available. For example, if we have one component which doesn't have any inputs (but does have outputs), it could be solved entirely, and doesn't need to be kept in sync with the global time. This could be utilised to ensure all available cores are working (with most dedicated to solving the current global time step and the remainder can still be utilised by solving future time steps of this component).","category":"page"},{"location":"examples/out_of_sync/","page":"Out of sync computation","title":"Out of sync computation","text":"We can do this in Mermaid with the QueueStepper. This solver creates a queue of all components which can be stepped, and assigns them to cores as they become available. After each component step has completed, we can find all components that depend on it and (assuming they aren't reliant on any other components/steps that need to run) add them to the queue.","category":"page"},{"location":"examples/out_of_sync/#Solving-with-out-of-sync-computations","page":"Out of sync computation","title":"Solving with out of sync computations","text":"","category":"section"},{"location":"examples/out_of_sync/","page":"Out of sync computation","title":"Out of sync computation","text":"TODO CFD flow informing Agents of enzymes, both informing a PDE of some chemical reactions","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, AbstractString}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, var::AbstractString)\n\nGet the solution array for a variable from a MermaidSolution.\n\nArguments\n\nsol::MermaidSolution: The solution object.\nvar::AbstractString: The variable name.\n\nReturns\n\nThe solution array for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, ConnectedVariable}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, var::ConnectedVariable)\n\nGet the solution array for a variable from a MermaidSolution.\n\nArguments\n\nsol::MermaidSolution: The solution object.\nvar::ConnectedVariable: The variable name.\n\nReturns\n\nThe solution array for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, index::Int)\n\nGet the solution array for a variable from a MermaidSolution at time sol.t[index].\n\nArguments\n\nsol::MermaidSolution: The solution object.\nindex::Int: The time index of the variable.\n\nReturns\n\nThe solution array for the specified index.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.init-Tuple{AgentsComponent, Vector{Connector}}","page":"API","title":"CommonSolve.init","text":"init(c::AgentsComponent, conns::Vector{Connector})\n\nInitializes an AgentsComponentIntegrator for the given AgentsComponent and its connections.\n\nArguments\n\nc::AgentsComponent: The AgentsComponent to be integrated.\nconns::Vector{Connector}: The Connectors that define the inputs and outputs of the component.\n\nReturns\n\nAgentsComponentIntegrator: The initialized integrator for the Agents.jl component.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.init-Tuple{MermaidProblem, AbstractMermaidSolver}","page":"API","title":"CommonSolve.init","text":"init(prob::MermaidProblem, alg::MermaidSolver; kwargs...)\n\nCreates a MermaidIntegrator from a MermaidProblem.\n\nArguments\n\nprob::MermaidProblem: The hybrid problem to be solved.\nalg::AbstractMermaidSolver: The AbstractMermaidSolver algorithm to be used for solving the problem.\nkwargs...: Additional keyword arguments for the solver.\n\nReturns\n\nMermaidIntegrator: The initialized integrator for the problem.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.solve!-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"CommonSolve.solve!","text":"solve!(int::MermaidIntegrator)\n\nSolves the problem using the MermaidIntegrator. This handles all the message passing and calls step! on the MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to be solved.\n\nReturns\n\nMermaidSolution: The solution of the problem.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.step!-Tuple{Mermaid.AgentsComponentIntegrator}","page":"API","title":"CommonSolve.step!","text":"step!(compInt::AgentsComponentIntegrator)\n\nSets the state based on the current inputs and steps the AgentsComponentIntegrator in time one step.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be stepped. Its internal state will be mutated.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.step!-Tuple{Mermaid.MermaidIntegrator, Any}","page":"API","title":"CommonSolve.step!","text":"step!(int::MermaidIntegrator, dt::Float64)\n\nSteps the integrator for the given time step. The method is defined by the alg field of the MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to be stepped.\ndt::Float64: The time step for the integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.getstate","page":"API","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator)\n\nReturns the current state of the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current state.\ncopy::Bool=false: If true, returns a deep copy of the state.\n\nReturns\n\nstate::StandardABM: The current state of the agent-based model being integrated.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.getstate-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable}","page":"API","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator, key::ConnectedVariable)\n\nRetrieves the state of a specific variable from the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to retrieve.\n\nReturns\n\nThe current state of the variable specified by key, which can be a model-level property or an agent-specific property.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.getstate-Tuple{Mermaid.MermaidIntegrator, ConnectedVariable}","page":"API","title":"Mermaid.getstate","text":"getstate(merInt::MermaidIntegrator, key::ConnectedVariable)\n\nRetrieve the state of a component within a MermaidIntegrator based on the provided ConnectedVariable.\n\nArguments\n\nmerInt::MermaidIntegrator: The integrator containing multiple component integrators.\nkey::ConnectedVariable: The key specifying which component's state to retrieve.\n\nReturns\n\nThe state associated with the specified key, or nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.gettime-Tuple{Mermaid.AgentsComponentIntegrator}","page":"API","title":"Mermaid.gettime","text":"gettime(compInt::AgentsComponentIntegrator)\n\nReturns the simulation time of the AgentsComponentIntegrator at the current state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current time.\n\nReturns\n\ntime: The current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.inputsandoutputs-Tuple{Mermaid.ComponentIntegrator, Vector{Connector}}","page":"API","title":"Mermaid.inputsandoutputs","text":"inputsandoutputs(integrator::ComponentIntegrator, conns::Vector{Connector}, compName::AbstractString)\n\nGenerates the inputs and outputs of a component integrator based on its connections.\n\nArguments\n\nintegrator::ComponentIntegrator: The component integrator whose inputs and outputs are to be extracted.\nconns::Vector{Connector}: The connectors that define the inputs and outputs of the component.\n\nReturns\n\noutputs::OrderedDict{ConnectedVariable,Any}: An ordered dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::OrderedDict{ConnectedVariable,Any}: An ordered dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.parsevariable-Tuple{Any}","page":"API","title":"Mermaid.parsevariable","text":"parsevariable(name::AbstractString) -> ConnectedVariable\n\nParses a variable name as a foramtted string to a ConnectedVariable.\n\nArguments\n\nname::AbstractString: The variable name to parse. It can include an optional index, which may be a single integer (e.g., \"comp.var[3]\") or a range (e.g., \"comp.var[1:5]\").\n\nReturns\n\nConnectedVariable: The corresponding ConnectedVariable, containing a component, variable, index (which can be nothing, an Int, or a UnitRange{Int}), and the original name.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, Agents.StandardABM}","page":"API","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, state::StandardABM)\n\nSets the state of the AgentsComponentIntegrator to a new state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be updated.\nstate::StandardABM: The new state to set for the component integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable, Any}","page":"API","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, key::ConnectedVariable, value)\n\nSets the state of a specific variable in the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to set.\nvalue: The value to assign to the specified variable's state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.MermaidIntegrator, ConnectedVariable, Any}","page":"API","title":"Mermaid.setstate!","text":"setstate!(merInt::MermaidIntegrator, key::ConnectedVariable, value)\n\nSet the state of a component integrator inside a MermaidIntegrator based on the provided key and value.\n\nArguments\n\nmerInt::MermaidIntegrator: The integrator containing multiple component integrators.\nkey::ConnectedVariable: The key specifying which component's state to set.\nvalue: The value to assign to the specified state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_inputs!-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.update_inputs!","text":"update_inputs!(mermaidInt::MermaidIntegrator)\n\nUpdates the input values of each ComponentIntegrator within the given MermaidIntegrator instance based on the outputs of other components and the defined Connectors.\n\nArguments\n\nmermaidInt::MermaidIntegrator: The integrator containing components, connectors, and their current states.\n\nDescription\n\nFor each connector in mermaidInt.connectors, this function:\n\nCollects the outputs from the source components specified in the connector's inputs.\nIf a function (conn.func) is defined for the connector, applies it to the collected inputs to compute the outputs; otherwise, passes the inputs directly.\nAssigns the resulting outputs to the appropriate input fields of the destination components specified in the connector's outputs.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_outputs!-Tuple{Mermaid.ComponentIntegrator}","page":"API","title":"Mermaid.update_outputs!","text":"update_outputs!(compInt::ComponentIntegrator)\n\nUpdate the outputs field of a ComponentIntegrator based on its current state.\n\nArguments\n\ncompInt::ComponentIntegrator: The component integrator whose outputs are to be updated.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_solution!-Tuple{MermaidSolution, Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.update_solution!","text":"update_solution!(sol::MermaidSolution, merInt::MermaidIntegrator)\n\nUpdate the MermaidSolution sol with the current time and state from the MermaidIntegrator.\n\nArguments\n\nsol::MermaidSolution: The MermaidSolution to be updated. It contains time points (t) and a dictionary of state histories (u).\nmerInt::MermaidIntegrator: The integrator object providing the current time (currtime) and state access via getstate.\n\nDescription\n\nAppends the current time from merInt to sol.t. For each key in sol.u, retrieves the corresponding state from merInt using getstate and appends it to the respective vector in sol.u.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.AbstractMermaidSolver","page":"API","title":"Mermaid.AbstractMermaidSolver","text":"AbstractMermaidSolver\n\nBase type for all solvers in the Mermaid framework.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AgentsComponent","page":"API","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AgentsComponentIntegrator","page":"API","title":"Mermaid.AgentsComponentIntegrator","text":"AgentsComponentIntegrator <: ComponentIntegrator\n\nA mutable struct that integrates an AgentsComponent using the Agents.jl package.\n\nFields\n\nintegrator::StandardABM: The agent-based model integrator.\ncomponent::AgentsComponent: The AgentsComponent being integrated.\noutputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ComponentIntegrator","page":"API","title":"Mermaid.ComponentIntegrator","text":"ComponentIntegrator\n\nBase type for all component integrators in the Mermaid framework.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable\n\nPoints to a variable that is connected between components.\n\nFields\n\ncomponent::String: Name of the component.\nvariable::String: Name of the variable.\nvariableindex::Union{Nothing,AbstractVector{Int},Int}: Index or range for the variable, if applicable.\nduplicatedindex::Union{Nothing,AbstractVector{Int},Int}: Index for duplicated components, if applicable.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable-Tuple{AbstractString}","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable(name::AbstractString)\n\nConstruct a ConnectedVariable from a string name.\n\nArguments\n\nname::AbstractString: The full variable name.\n\nReturns\n\nConnectedVariable: The parsed connected variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.Connector","page":"API","title":"Mermaid.Connector","text":"Connector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{ConnectedVariable}: Input variables for the connector.\noutputs::Vector{ConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.Connector-Union{Tuple{}, Tuple{T}, Tuple{S}} where {S<:AbstractString, T<:AbstractString}","page":"API","title":"Mermaid.Connector","text":"Connector(;inputs, outputs, func=nothing)\n\nConstruct a Connector from string names for inputs and outputs.\n\nKeyword Arguments\n\ninputs::Vector{<:AbstractString}: Names of input variables.\noutputs::Vector{<:AbstractString}: Names of output variables.\nfunc: Optional function for transformation (default: nothing).\n\nReturns\n\nConnector: The constructed connector.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.DuplicatedComponent","page":"API","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninitial_states::Vector: Vector of states for the duplicated component, where each state corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidIntegrator","page":"API","title":"Mermaid.MermaidIntegrator","text":"MermaidIntegrator\n\nMutable struct for integrating a hybrid MermaidProblem. This struct holds all the ComponentIntegrators and Connectors to store the current state of the hybrid simulation.\n\nFields\n\nintegrators::Vector: Vector of ComponentIntegrator.\nconnectors::Vector{Connector}: Vector of Connector.\nmaxt::Float64: Maximum simulation time.\ncurrtime::Float64: Current simulation time.\nalg::AbstractMermaidSolver: Algorithm used for integration.\nsave_vars::Vector{String}: Variables to save during integration.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidProblem","page":"API","title":"Mermaid.MermaidProblem","text":"MermaidProblem\n\nStruct for defining a Mermaid problem. This struct contains the components, connectors and other properties of the hybrid simulation.\n\nFields\n\ncomponents::Vector: Vector of Components.\nconnectors::Vector{Connector}: Vector of Connector.\nmax_t::Float64=1.0: Maximum simulation time.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution\n\nStruct for storing the solution of a hybrid Mermaid simulation.\n\nFields\n\nt::Vector: Time points.\nu::Dict: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution(int::MermaidIntegrator)\n\nConstruct a MermaidSolution from a MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to extract solution structure from.\n\nReturns\n\nMermaidSolution: The initialized solution object.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MermaidSolution-Tuple{Real}","page":"API","title":"Mermaid.MermaidSolution","text":"(sol::MermaidSolution)(t::Real)\n\nInterpolates the solution at a given time t using linear interpolation.\n\nArguments\n\nsol::MermaidSolution: The solution object containing time points and state histories.\nt::Real: The time at which to interpolate the solution.\n\nReturns\n\nMermaidSolution: A new MermaidSolution object containing the interpolated time and state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MinimumTimeStepper","page":"API","title":"Mermaid.MinimumTimeStepper","text":"MinimumTimeStepper()\n\nA solver that steps the integrators in a MermaidIntegrator at the minimum time step of all components.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ODEComponent","page":"API","title":"Mermaid.ODEComponent","text":"ODEComponent <: AbstractTimeDependentComponent\n\nA component that represents an ODE system, defined by an ODEProblem.\n\nFields\n\nmodel::ODEProblem: The ODE problem to be solved.\nname::String=\"ODE Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping variable names (as strings) to their corresponding indices in the state vector or symbols from ModelingToolkit/Symbolics.\ntime_step::Float64=1.0: The time step for the component (not the ODE solver timestep), i.e. how frequently should the inputs and outputs be updated.\nalg=Rodas5(): The algorithm used for solving the ODEProblem.\nintkwargs::Tuple=(): Additional keyword arguments for the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"#Mermaid.jl","page":"Introduction","title":"Mermaid.jl","text":"","category":"section"},{"location":"#Summary-/-README","page":"Introduction","title":"Summary / README","text":"","category":"section"},{"location":"#Mermaid.Mermaid","page":"Introduction","title":"Mermaid.Mermaid","text":"Mermaid.jl\n\n(Image: Run tests) (Image: codecov)\n\nMermaid.jl is a general purpose component-based simulation tool in Julia. It allows users to connect arbitrary Julia models from a wide range of packages to produce complex coupled simulations.\n\nAny simulation that can be performed in Julia can be included as a component, from DifferentialEquations.jl, to Agents.jl and beyond.\nSimple interface for extending components to tools not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"#Installation-(Coming-soon)","page":"Introduction","title":"Installation (Coming soon)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Mermaid can be installed from Julia with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"Mermaid\")","category":"page"},{"location":"#FAQ","page":"Introduction","title":"FAQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: How can I use Mermaid to run a hybrid model simulation?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: Check out the Tutorial, it covers how to set up and run a hybrid simualtion between an Agent-based model and an ODE system.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: What if Mermaid doesn't have a component for the type of model I want to use?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: Check out the Mermaid Interface, you can easily define new components for many different simulation tools.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: The Tutorial didn't cover what I wanted. Where can I view more examples?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: In the Examples section of course. We have examples showing all of the more advanced features of Mermaid including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"duplicated components,\nout of sync computation,\nexternal (non-Julia) components,\nsurrogate model approximations,\nmapping between spatial components on different resolutions,\nintegration with ModelingToolkit.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: Is Mermaid the right tool for me?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: That depends on what type of hybrid simulation you are looking to run. Luckily, you can check out Is Mermaid right for me? and find out.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a hybrid simulation between an Agent-based model, defined in Agents.jl, and an ODE system defined through DifferentialEquations.jl.\nIntroduce Mermaid Components for Agents.jl and DifferentialEquations.jl.\nDemonstrate how these Components can be connected together through Connections.\nSolve the hybrid model.\nVisualise the results of the simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The example system we will use for this will be a model of a forest fire (governed by an Agent-based model), with the growth of each tree informed by an ODE model.","category":"page"},{"location":"tutorial/#Components","page":"Tutorial","title":"Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To begin, we need to define our components. These will be an ODE model component for each tree, and an Agent-based model component for handling the forest level properties (in this case, the spread of heat/fire).","category":"page"},{"location":"tutorial/#ODE-Components","page":"Tutorial","title":"ODE Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To define the ODE model, let's have a look at how to define an ODE Component.","category":"page"},{"location":"tutorial/#Mermaid.ODEComponent-tutorial","page":"Tutorial","title":"Mermaid.ODEComponent","text":"ODEComponent <: AbstractTimeDependentComponent\n\nA component that represents an ODE system, defined by an ODEProblem.\n\nFields\n\nmodel::ODEProblem: The ODE problem to be solved.\nname::String=\"ODE Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping variable names (as strings) to their corresponding indices in the state vector or symbols from ModelingToolkit/Symbolics.\ntime_step::Float64=1.0: The time step for the component (not the ODE solver timestep), i.e. how frequently should the inputs and outputs be updated.\nalg=Rodas5(): The algorithm used for solving the ODEProblem.\nintkwargs::Tuple=(): Additional keyword arguments for the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that we need to define an ODEProblem to use in the component, so let's create one.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentialEquations\nfunction tree!(du, u, p, t)\n    heat, life = u\n    du[1] = 0\n    du[2] = (life*(1-life/10.0)-heat*life)/10\nend\nu0 = [4.0, 2.0]\ntspan = (0.0, 150.0)\nprob = ODEProblem(tree!, u0, tspan)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we want to wrap this ODEProblem inside an ODEComponent. For this, we will need to define the state_names field, and should generally provide a value for the name field (since component names in a hybrid simulation should be unique).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Mermaid\ncomp1 = ODEComponent(\n    model=prob,\n    name=\"tree\",\n    state_names=Dict(\"heat\" => 1, \"life\" => 2),\n)","category":"page"},{"location":"tutorial/#Duplicated-Components","page":"Tutorial","title":"Duplicated Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since the ODEProblem is defined for only a single tree, we can efficiently simulate the ODE by generating a duplicated component. This component stores a single ODEProblem will solve across many different states. In this case, we can have a state for each tree in the Agent-based model. Let's have a look at how to define a DuplicatedComponent.","category":"page"},{"location":"tutorial/#Mermaid.DuplicatedComponent-tutorial","page":"Tutorial","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninitial_states::Vector: Vector of states for the duplicated component, where each state corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dup_comp = DuplicatedComponent(\n    component=comp1,\n    instances=640,\n    initial_states=[copy(u0) for _ in 1:640]\n)","category":"page"},{"location":"tutorial/#Agents.jl-Components","page":"Tutorial","title":"Agents.jl Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have created our ODEComponent, we can move on to the AgentsComponent, so let's have a look at its documentation.","category":"page"},{"location":"tutorial/#Mermaid.AgentsComponent-tutorial","page":"Tutorial","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see that, again, we need to define the model (this time a StandardABM from Agents.jl), a name and a state_names.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Agents, Random, Statistics\n@agent struct Tree(GridAgent{2})\n    heat::Float64 # Heat is averaged across neighbors, passed to ODE model\n    life::Float64 # Life is informed by ODE model\nend\n\nfunction forest_fire(; density=0.4, griddims=(40, 40), seed=2)\n    space = GridSpaceSingle(griddims; periodic=false, metric=:chebyshev)\n    rng = Random.MersenneTwister(seed)\n    forest = StandardABM(Tree, space; rng, agent_step! = tree_step!)\n    for _ in 1:floor(density * prod(griddims))\n        # Randomly place trees in the grid\n        add_agent_single!(forest; heat=rand(), life=rand())\n    end\n    return forest\nend\n\nfunction tree_step!(tree, forest)\n    nearbyheat = mean([getproperty(neighbor, :heat) for neighbor in nearby_agents(tree, forest, 1)])\n    if isnan(nearbyheat)\n        nearbyheat = 0.0\n    end\n    tree.heat = tree.heat * 0.9 + nearbyheat * 0.1\n    if rand(abmrng(forest)) < 1e-4 # Random chance of fire\n        tree.heat = 10.0\n    end\n    # Simulate tree life cycle\n    if tree.heat > 1.0 && tree.life > 1.0\n        # Tree on fire\n        tree.heat += 1.0\n    else\n        # Tree not on fire so heat disappates\n        tree.heat -= 0.05\n    end\n    if tree.heat < 0.0\n        tree.heat = 0.0\n    end\nend\n\nforest = forest_fire()\n\ncomp2 = AgentsComponent(\n    model=forest,\n    name=\"forest\",\n    state_names=Dict(\"heat\" => :heat, \"life\" => :life)\n)","category":"page"},{"location":"tutorial/#Connections","page":"Tutorial","title":"Connections","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now set up the connections between the variables in the two components.","category":"page"},{"location":"tutorial/#Mermaid.Connector-tutorial","page":"Tutorial","title":"Mermaid.Connector","text":"Connector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{ConnectedVariable}: Input variables for the connector.\noutputs::Vector{ConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"conn1 = Connector(inputs=[\"forest.heat[1:640]\"], outputs=[\"tree[1:640].heat\"])\nconn2 = Connector(inputs=[\"tree[1:640].life\"], outputs=[\"forest.life[1:640]\"])","category":"page"},{"location":"tutorial/#Solving-the-hybrid-model","page":"Tutorial","title":"Solving the hybrid model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To create the hybrid model, we need to create a MermaidProblem. We can then solve this using the CommonSolve interface.","category":"page"},{"location":"tutorial/#Mermaid.MermaidProblem-tutorial","page":"Tutorial","title":"Mermaid.MermaidProblem","text":"MermaidProblem\n\nStruct for defining a Mermaid problem. This struct contains the components, connectors and other properties of the hybrid simulation.\n\nFields\n\ncomponents::Vector: Vector of Components.\nconnectors::Vector{Connector}: Vector of Connector.\nmax_t::Float64=1.0: Maximum simulation time.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2], max_t=tspan[2])\nalg = MinimumTimeStepper()\nsol = solve(mp, alg)","category":"page"},{"location":"tutorial/#Plotting-the-solution","page":"Tutorial","title":"Plotting the solution","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After running solve, we get sol, a MermaidSolution instance. This stores all variables given in state_names at each timepoint.","category":"page"},{"location":"tutorial/#Mermaid.MermaidSolution-tutorial","page":"Tutorial","title":"Mermaid.MermaidSolution","text":"MermaidSolution\n\nStruct for storing the solution of a hybrid Mermaid simulation.\n\nFields\n\nt::Vector: Time points.\nu::Dict: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nplot(sol.t, sol[\"forest.life[1]\"], color=:green, label=\"Life\")\nplot!(sol.t, sol[\"forest.heat[1]\"], color=:red, label=\"Heat\")","category":"page"},{"location":"tutorial/#Advanced-Visualisations","page":"Tutorial","title":"Advanced Visualisations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While we can plot the variables from the ODE component easily, the Agent-based model is a bit more challenging. But default, we only store the variables given in state_names in the solution. This can be changed by providing save_vars=[\"forest.#model\"] to solve, in which case the full Agent-based model state will be visable in the solution at all timepoints. However, this can be wasteful if we know we only want an animation of the model (which can be generated during simulation).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will set up a Connector which takes an input of the model's current state, and instead of a transformation, we will use a function which adds the current state to a video.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Makie\nusing CairoMakie\n\ngroupcolor(tree) = tree.heat > 1 ? :red : :green\ngroupmarker(a) = a.life > 1 ? :utriangle : :circle\nfig, ax = abmplot(forest; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\nio = VideoStream(fig)\nfunction plot_input(model)\n    empty!(ax)\n    abmplot!(ax, model; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\n    recordframe!(io)\nend\n\nconn3 = Connector(\n    inputs=[\"forest.#model\"],\n    outputs=Vector{String}(),\n    func=(model) -> plot_input(model)\n)\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2, conn3], max_t=tspan[2])\nsol = solve(mp, alg)\n\nsave(\"forest_fire.mp4\", io)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: An animation of the forest fire simulation)","category":"page"}]
}
