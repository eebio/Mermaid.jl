var documenterSearchIndex = {"docs":
[{"location":"interface/#Mermaid-Interface","page":"Mermaid Interface","title":"Mermaid Interface","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"In this section, we will:","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"See the integrator interface that Mermaid uses,\nFind out how this fits with CommonSolve,\nLook at how the AgentsComponent is defined, as an example.","category":"page"},{"location":"interface/#Interface-requirements","page":"Mermaid Interface","title":"Interface requirements","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The interface used is Mermaid is compatible with, and uses, the SciML CommonSolve interface. In particular, each Component is some immutable problem type that stores required data to solve a Component (for example, an ODEProblem). We then also have an Integrator for each Component which stores the current state and handles solving over time.","category":"page"},{"location":"interface/#Component","page":"Mermaid Interface","title":"Component","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"There are two categories of Components in Mermaid. AbstractTimeDependentComponents and AbstractTimeIndependentComponents, both of which are AbstractComponents.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"A component must contain the following fields:","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"name which is a subtype of AbstractString,\ntime_step which is a Float64,\nstate_names which is a Dict which maps from variable names in the form of a String (variable name format) to some other object (typically a numerical index or symbol) which can be used to identify that variable internally.","category":"page"},{"location":"interface/#Integrator","page":"Mermaid Interface","title":"Integrator","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"A ComponentIntegrator is a mutable struct which can be freely modified over a simulation, since it will be typically discarded at the end. It typically only stores the current state of that component, and has some associated functions for handling this state.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"In addition to having some functions defined on the integrator, we also have some required fields.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"outputs and inputs are Dicts for mapping from a ConnectedVariable to its current value. The values in these Dicts are set by Mermaid but the initial creation of this Dict (in particular, its keys) need to be defined in the init function. The values from inputs should be used to set the state during the step! function.\nThe original Component should also be stored under the field name component. This allows access to any problem settings, or other fields like the name.","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"todo: setstate! and inputs\nCouldn't the state be set by mermaid, rather than in the step function?","category":"page"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"warning: Warning\nAn Integrator is required for all Components, even TimeIndependentComponents. They just store the state that they were last called with.","category":"page"},{"location":"interface/#Functions","page":"Mermaid Interface","title":"Functions","text":"","category":"section"},{"location":"interface/#step!","page":"Mermaid Interface","title":"step!","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The step! function should advance the ComponentIntegrator (its only input) one time step (defined by Component.time_step). This should also include reading the inputs field and updating the integrators internal state accordingly.","category":"page"},{"location":"interface/#init","page":"Mermaid Interface","title":"init","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The init function takes as inputs a Component and a Vector{Connector} and returns the corresponding ComponentIntegrator. This includes the process of creating the inputs and outputs Dicts which require the keys to be specified, i.e. the init function should read through the Vector{Connector} and look for any outputs or inputs into this component, and add the ConnectedVariables as keys to the inputs and outputs Dicts.","category":"page"},{"location":"interface/#getstate-and-setstate!","page":"Mermaid Interface","title":"getstate and setstate!","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"The function getstate function reads the state of a ComponentIntegrator at a given ConnectedVariable and returns it. The setstate! function similarly mutates the current state of the ComponentIntegrator to assign an inputted value to the ConnectedVariable.","category":"page"},{"location":"interface/#gettime","page":"Mermaid Interface","title":"gettime","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"Simply returns the current simulated time of a ComponentIntegrator.","category":"page"},{"location":"interface/#AgentsComponent-Example","page":"Mermaid Interface","title":"AgentsComponent Example","text":"","category":"section"},{"location":"interface/","page":"Mermaid Interface","title":"Mermaid Interface","text":"todo: Code example\nWe should include the code of the Agents component here too. probably with literate","category":"page"},{"location":"interface/#Mermaid.AgentsComponent-interface","page":"Mermaid Interface","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Mermaid.AgentsComponentIntegrator-interface","page":"Mermaid Interface","title":"Mermaid.AgentsComponentIntegrator","text":"AgentsComponentIntegrator <: ComponentIntegrator\n\nA mutable struct that integrates an AgentsComponent using the Agents.jl package.\n\nFields\n\nintegrator::StandardABM: The agent-based model integrator.\ncomponent::AgentsComponent: The AgentsComponent being integrated.\noutputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"type"},{"location":"interface/#CommonSolve.step!-Tuple{Mermaid.AgentsComponentIntegrator}-interface","page":"Mermaid Interface","title":"CommonSolve.step!","text":"step!(compInt::AgentsComponentIntegrator)\n\nSets the state based on the current inputs and steps the AgentsComponentIntegrator in time one step.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be stepped. Its internal state will be mutated.\n\n\n\n\n\n","category":"method"},{"location":"interface/#CommonSolve.init-Tuple{AgentsComponent, Vector{Connector}}-interface","page":"Mermaid Interface","title":"CommonSolve.init","text":"init(c::AgentsComponent, conns::Vector{Connector})\n\nInitializes an AgentsComponentIntegrator for the given AgentsComponent and its connections.\n\nArguments\n\nc::AgentsComponent: The AgentsComponent to be integrated.\nconns::Vector{Connector}: The Connectors that define the inputs and outputs of the component.\n\nReturns\n\nAgentsComponentIntegrator: The initialized integrator for the Agents.jl component.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.getstate-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable}-interface","page":"Mermaid Interface","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator, key::ConnectedVariable)\n\nRetrieves the state of a specific variable from the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to retrieve.\n\nReturns\n\nThe current state of the variable specified by key, which can be a model-level property or an agent-specific property.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable, Any}-interface","page":"Mermaid Interface","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, key::ConnectedVariable, value)\n\nSets the state of a specific variable in the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to set.\nvalue: The value to assign to the specified variable's state.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Mermaid.gettime-Tuple{Mermaid.AgentsComponentIntegrator}-interface","page":"Mermaid Interface","title":"Mermaid.gettime","text":"gettime(compInt::AgentsComponentIntegrator)\n\nReturns the simulation time of the AgentsComponentIntegrator at the current state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current time.\n\nReturns\n\ntime: The current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Variable-Names","page":"Mermaid Interface","title":"Variable Names","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Is-Mermaid-right-for-me?","page":"Is Mermaid right for me?","title":"Is Mermaid right for me?","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Comparison-to-other-software","page":"Is Mermaid right for me?","title":"Comparison to other software","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#ModelingToolkit.jl","page":"Is Mermaid right for me?","title":"ModelingToolkit.jl","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Modia.jl?","page":"Is Mermaid right for me?","title":"Modia.jl?","text":"","category":"section"},{"location":"is_mermaid_right_for_me/#Causal.jl","page":"Is Mermaid right for me?","title":"Causal.jl","text":"","category":"section"},{"location":"examples/mtk/#ModelingToolkit","page":"ModelingToolkit","title":"ModelingToolkit","text":"","category":"section"},{"location":"#Mermaid.jl","page":"Introduction","title":"Mermaid.jl","text":"","category":"section"},{"location":"#Summary-/-README","page":"Introduction","title":"Summary / README","text":"","category":"section"},{"location":"#Mermaid.Mermaid","page":"Introduction","title":"Mermaid.Mermaid","text":"Mermaid.jl\n\n(Image: Run tests) (Image: codecov)\n\nMermaid.jl is a general purpose component-based simulation tool in Julia. It allows users to connect arbitrary Julia models from a wide range of packages to produce complex coupled simulations.\n\nAny simulation that can be performed in Julia can be included as a component, from DifferentialEquations.jl, to Agents.jl and beyond.\nSimple interface for extending components to tools not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"#Installation-(Coming-soon)","page":"Introduction","title":"Installation (Coming soon)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Mermaid can be installed from Julia with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"Mermaid\")","category":"page"},{"location":"#FAQ","page":"Introduction","title":"FAQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: How can I use Mermaid to run a hybrid model simulation?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: Check out the Tutorial, it covers how to set up and run a hybrid simualtion between an Agent-based model and an ODE system.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: What if Mermaid doesn't have a component for the type of model I want to use?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: Check out the Mermaid Interface, you can easily define new components for many different simulation tools.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: Where can I view more examples?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A: In the Examples section of course. We have examples showing all of the more advanced features of Mermaid including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"duplicated components,\nout of sync computation,\nexternal (non-Julia) components,\nsurrogate model approximations,\nmapping between spatial components on different resolutions,\nintegration with ModelingToolkit.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Q: Is Mermaid the right tool for me? A: That depends on what type of hybrid simulation you are looking to run. Luckily, you can check out Is Mermaid right for me? and find out.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a hybrid simulation between an Agent-based model, defined in Agents.jl, and an ODE system defined through DifferentialEquations.jl.\nIntroduce Mermaid Components for Agents.jl and DifferentialEquations.jl.\nDemonstrate how these Components can be connected together through Connections.\nSolve the hybrid model.\nVisualise the results of the simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The example system we will use for this will be a model of a forest fire (governed by an Agent-based model), with the growth of each tree informed by an ODE model.","category":"page"},{"location":"tutorial/#Components","page":"Tutorial","title":"Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To begin, we need to define our components. These will be an ODE model component for each tree, and an Agent-based model component for handling the forest level properties (in this case, the spread of heat/fire).","category":"page"},{"location":"tutorial/#ODE-Components","page":"Tutorial","title":"ODE Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To define the ODE model, let's have a look at how to define an ODE Component.","category":"page"},{"location":"tutorial/#Mermaid.ODEComponent-tutorial","page":"Tutorial","title":"Mermaid.ODEComponent","text":"ODEComponent <: AbstractTimeDependentComponent\n\nA component that represents an ODE system, defined by an ODEProblem.\n\nFields\n\nmodel::ODEProblem: The ODE problem to be solved.\nname::String=\"ODE Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping variable names (as strings) to their corresponding indices in the state vector or symbols from ModelingToolkit/Symbolics.\ntime_step::Float64=1.0: The time step for the component (not the ODE solver timestep), i.e. how frequently should the inputs and outputs be updated.\nalg=Rodas5(): The algorithm used for solving the ODEProblem.\nintkwargs::Tuple=(): Additional keyword arguments for the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that we need to define an ODEProblem to use in the component, so let's create one.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentialEquations\nfunction tree!(du, u, p, t)\n    x, y = u\n    du[1] = 0\n    du[2] = (y*(1-y/10.0)-x*y)/10\nend\nu0 = [4.0, 2.0]\ntspan = (0.0, 150.0)\nprob = ODEProblem(tree!, u0, tspan)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we want to wrap this ODEProblem inside an ODEComponent. For this, we will need to define the state_names field, and should generally provide a value for the name field (since component names in a hybrid simulation should be unique).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Mermaid\ncomp1 = ODEComponent(\n    model=prob,\n    name=\"tree\",\n    state_names=Dict(\"heat\" => 1, \"life\" => 2),\n)","category":"page"},{"location":"tutorial/#Duplicated-Components","page":"Tutorial","title":"Duplicated Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since the ODEProblem is defined for only a single tree, we can efficiently simulate the ODE by generating a duplicated component. This component stores a single ODEProblem will solve across many different states. In this case, we can have a state for each tree in the Agent-based model. Let's have a look at how to define a DuplicatedComponent.","category":"page"},{"location":"tutorial/#Mermaid.DuplicatedComponent-tutorial","page":"Tutorial","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninitial_states::Vector: Vector of states for the duplicated component, where each state corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dup_comp = DuplicatedComponent(\n    component=comp1,\n    instances=640,\n    initial_states=[copy(u0) for _ in 1:640]\n)","category":"page"},{"location":"tutorial/#Agents.jl-Components","page":"Tutorial","title":"Agents.jl Components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have created our ODEComponent, we can move on to the AgentsComponent, so let's have a look at its documentation.","category":"page"},{"location":"tutorial/#Mermaid.AgentsComponent-tutorial","page":"Tutorial","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see that, again, we need to define the model (this time a StandardABM from Agents.jl), a name and a state_names.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Agents, Random, Statistics\n@agent struct Tree(GridAgent{2})\n    heat::Float64 # Heat is averaged across neighbors, passed to ODE model\n    life::Float64 # Life is informed by ODE model\nend\n\nfunction forest_fire(; density=0.4, griddims=(40, 40), seed=2)\n    space = GridSpaceSingle(griddims; periodic=false, metric=:chebyshev)\n    rng = Random.MersenneTwister(seed)\n    forest = StandardABM(Tree, space; rng, agent_step! = tree_step!)\n    for _ in 1:floor(density * prod(griddims))\n        # Randomly place trees in the grid\n        add_agent_single!(forest; heat=rand(), life=rand())\n    end\n    return forest\nend\n\nfunction tree_step!(tree, forest)\n    nearbyheat = mean([getproperty(neighbor, :heat) for neighbor in nearby_agents(tree, forest, 1)])\n    if isnan(nearbyheat)\n        nearbyheat = 0.0\n    end\n    tree.heat = tree.heat * 0.9 + nearbyheat * 0.1\n    if rand(abmrng(forest)) < 1e-4 # Random chance of fire\n        tree.heat = 10.0\n    end\n    # Simulate tree life cycle\n    if tree.heat > 1.0 && tree.life > 1.0\n        # Tree on fire\n        tree.heat += 1.0\n    else\n        # Tree not on fire so heat disappates\n        tree.heat -= 0.05\n    end\n    if tree.heat < 0.0\n        tree.heat = 0.0\n    end\nend\n\nforest = forest_fire()\n\ncomp2 = AgentsComponent(\n    model=forest,\n    name=\"forest\",\n    state_names=Dict(\"heat\" => :heat, \"life\" => :life)\n)","category":"page"},{"location":"tutorial/#Connections","page":"Tutorial","title":"Connections","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now set up the connections between the variables in the two components.","category":"page"},{"location":"tutorial/#Mermaid.Connector-tutorial","page":"Tutorial","title":"Mermaid.Connector","text":"Connector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{ConnectedVariable}: Input variables for the connector.\noutputs::Vector{ConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"conn1 = Connector(inputs=[\"forest.heat[1:640]\"], outputs=[\"tree[1:640].heat\"])\nconn2 = Connector(inputs=[\"tree[1:640].life\"], outputs=[\"forest.life[1:640]\"])","category":"page"},{"location":"tutorial/#Solving-the-hybrid-model","page":"Tutorial","title":"Solving the hybrid model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To create the hybrid model, we need to create a MermaidProblem. We can then solve this using the CommonSolve interface.","category":"page"},{"location":"tutorial/#Mermaid.MermaidProblem-tutorial","page":"Tutorial","title":"Mermaid.MermaidProblem","text":"MermaidProblem\n\nStruct for defining a Mermaid problem. This struct contains the components, connectors and other properties of the hybrid simulation.\n\nFields\n\ncomponents::Vector: Vector of Components.\nconnectors::Vector{Connector}: Vector of Connector.\nmax_t::Float64=1.0: Maximum simulation time.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2], max_t=tspan[2])\nalg = MinimumTimeStepper()\nsol = solve(mp, alg)","category":"page"},{"location":"tutorial/#Plotting-the-solution","page":"Tutorial","title":"Plotting the solution","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After running solve, we get sol, a MermaidSolution instance. This stores all variables given in state_names at each timepoint.","category":"page"},{"location":"tutorial/#Mermaid.MermaidSolution-tutorial","page":"Tutorial","title":"Mermaid.MermaidSolution","text":"MermaidSolution\n\nStruct for storing the solution of a hybrid Mermaid simulation.\n\nFields\n\nt::Vector: Time points.\nu::Dict: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nplot(sol.t, sol[\"forest.life[1]\"], color=:green, label=\"Life\")\nplot!(sol.t, sol[\"forest.heat[1]\"], color=:red, label=\"Heat\")","category":"page"},{"location":"tutorial/#Advanced-Visualisations","page":"Tutorial","title":"Advanced Visualisations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While we can plot the variables from the ODE component easily, the Agent-based model is a bit more challenging. But default, we only store the variables given in state_names in the solution. This can be changed by providing save_vars=[\"forest.#model\"] to solve, in which case the full Agent-based model state will be visable in the solution at all timepoints. However, this can be wasteful if we know we only want an animation of the model (which can be generated during simulation).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will set up a Connector which takes an input of the model's current state, and instead of a transformation, we will use a function which adds the current state to a video.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Makie\nusing CairoMakie\n\ngroupcolor(tree) = tree.heat > 1 ? :red : :green\ngroupmarker(a) = a.life > 1 ? :utriangle : :circle\nfig, ax = abmplot(forest; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\nio = VideoStream(fig)\nfunction plot_input(model)\n    empty!(ax)\n    abmplot!(ax, model; agent_color=groupcolor, agent_marker=groupmarker, agent_size=10)\n    recordframe!(io)\nend\n\nconn3 = Connector(\n    inputs=[\"forest.#model\"],\n    outputs=Vector{String}(),\n    func=(model) -> plot_input(model)\n)\n\nmp = MermaidProblem(components=[dup_comp, comp2], connectors=[conn1, conn2, conn3], max_t=tspan[2])\nsol = solve(mp, alg)\n\nsave(\"forest_fire.mp4\", io)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: An animation of the forest fire simulation)","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, AbstractString}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, var::AbstractString)\n\nGet the solution array for a variable from a MermaidSolution.\n\nArguments\n\nsol::MermaidSolution: The solution object.\nvar::AbstractString: The variable name.\n\nReturns\n\nThe solution array for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, ConnectedVariable}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, var::ConnectedVariable)\n\nGet the solution array for a variable from a MermaidSolution.\n\nArguments\n\nsol::MermaidSolution: The solution object.\nvar::ConnectedVariable: The variable name.\n\nReturns\n\nThe solution array for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{MermaidSolution, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(sol::MermaidSolution, index::Int)\n\nGet the solution array for a variable from a MermaidSolution at time sol.t[index].\n\nArguments\n\nsol::MermaidSolution: The solution object.\nindex::Int: The time index of the variable.\n\nReturns\n\nThe solution array for the specified index.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.init-Tuple{AgentsComponent, Vector{Connector}}","page":"API","title":"CommonSolve.init","text":"init(c::AgentsComponent, conns::Vector{Connector})\n\nInitializes an AgentsComponentIntegrator for the given AgentsComponent and its connections.\n\nArguments\n\nc::AgentsComponent: The AgentsComponent to be integrated.\nconns::Vector{Connector}: The Connectors that define the inputs and outputs of the component.\n\nReturns\n\nAgentsComponentIntegrator: The initialized integrator for the Agents.jl component.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.init-Tuple{MermaidProblem, AbstractMermaidSolver}","page":"API","title":"CommonSolve.init","text":"init(prob::MermaidProblem, alg::MermaidSolver; kwargs...)\n\nCreates a MermaidIntegrator from a MermaidProblem.\n\nArguments\n\nprob::MermaidProblem: The hybrid problem to be solved.\nalg::AbstractMermaidSolver: The AbstractMermaidSolver algorithm to be used for solving the problem.\nkwargs...: Additional keyword arguments for the solver.\n\nReturns\n\nMermaidIntegrator: The initialized integrator for the problem.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.solve!-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"CommonSolve.solve!","text":"solve!(int::MermaidIntegrator)\n\nSolves the problem using the MermaidIntegrator. This handles all the message passing and calls step! on the MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to be solved.\n\nReturns\n\nMermaidSolution: The solution of the problem.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.step!-Tuple{Mermaid.AgentsComponentIntegrator}","page":"API","title":"CommonSolve.step!","text":"step!(compInt::AgentsComponentIntegrator)\n\nSets the state based on the current inputs and steps the AgentsComponentIntegrator in time one step.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be stepped. Its internal state will be mutated.\n\n\n\n\n\n","category":"method"},{"location":"API/#CommonSolve.step!-Tuple{Mermaid.MermaidIntegrator, Any}","page":"API","title":"CommonSolve.step!","text":"step!(int::MermaidIntegrator, dt::Float64)\n\nSteps the integrator for the given time step. The method is defined by the alg field of the MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to be stepped.\ndt::Float64: The time step for the integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.getstate","page":"API","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator)\n\nReturns the current state of the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current state.\ncopy::Bool=false: If true, returns a deep copy of the state.\n\nReturns\n\nstate::StandardABM: The current state of the agent-based model being integrated.\n\n\n\n\n\n","category":"function"},{"location":"API/#Mermaid.getstate-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable}","page":"API","title":"Mermaid.getstate","text":"getstate(compInt::AgentsComponentIntegrator, key::ConnectedVariable)\n\nRetrieves the state of a specific variable from the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to retrieve.\n\nReturns\n\nThe current state of the variable specified by key, which can be a model-level property or an agent-specific property.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.getstate-Tuple{Mermaid.MermaidIntegrator, ConnectedVariable}","page":"API","title":"Mermaid.getstate","text":"getstate(merInt::MermaidIntegrator, key::ConnectedVariable)\n\nRetrieve the state of a component within a MermaidIntegrator based on the provided ConnectedVariable.\n\nArguments\n\nmerInt::MermaidIntegrator: The integrator containing multiple component integrators.\nkey::ConnectedVariable: The key specifying which component's state to retrieve.\n\nReturns\n\nThe state associated with the specified key, or nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.gettime-Tuple{Mermaid.AgentsComponentIntegrator}","page":"API","title":"Mermaid.gettime","text":"gettime(compInt::AgentsComponentIntegrator)\n\nReturns the simulation time of the AgentsComponentIntegrator at the current state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator for which to retrieve the current time.\n\nReturns\n\ntime: The current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.inputsandoutputs-Tuple{Mermaid.ComponentIntegrator, Vector{Connector}}","page":"API","title":"Mermaid.inputsandoutputs","text":"inputsandoutputs(integrator::ComponentIntegrator, conns::Vector{Connector}, compName::AbstractString)\n\nGenerates the inputs and outputs of a component integrator based on its connections.\n\nArguments\n\nintegrator::ComponentIntegrator: The component integrator whose inputs and outputs are to be extracted.\nconns::Vector{Connector}: The connectors that define the inputs and outputs of the component.\n\nReturns\n\noutputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.parsevariable-Tuple{Any}","page":"API","title":"Mermaid.parsevariable","text":"parsevariable(name::AbstractString) -> ConnectedVariable\n\nParses a variable name as a foramtted string to a ConnectedVariable.\n\nArguments\n\nname::AbstractString: The variable name to parse. It can include an optional index, which may be a single integer (e.g., \"comp.var[3]\") or a range (e.g., \"comp.var[1:5]\").\n\nReturns\n\nConnectedVariable: The corresponding ConnectedVariable, containing a component, variable, index (which can be nothing, an Int, or a UnitRange{Int}), and the original name.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, Agents.StandardABM}","page":"API","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, state::StandardABM)\n\nSets the state of the AgentsComponentIntegrator to a new state.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator to be updated.\nstate::StandardABM: The new state to set for the component integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.AgentsComponentIntegrator, ConnectedVariable, Any}","page":"API","title":"Mermaid.setstate!","text":"setstate!(compInt::AgentsComponentIntegrator, key::ConnectedVariable, value)\n\nSets the state of a specific variable in the AgentsComponentIntegrator.\n\nArguments\n\ncompInt::AgentsComponentIntegrator: The component integrator containing the agent-based model.\nkey::ConnectedVariable: The ConnectedVariable specifying which variable's state to set.\nvalue: The value to assign to the specified variable's state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.setstate!-Tuple{Mermaid.MermaidIntegrator, ConnectedVariable, Any}","page":"API","title":"Mermaid.setstate!","text":"setstate!(merInt::MermaidIntegrator, key::ConnectedVariable, value)\n\nSet the state of a component integrator inside a MermaidIntegrator based on the provided key and value.\n\nArguments\n\nmerInt::MermaidIntegrator: The integrator containing multiple component integrators.\nkey::ConnectedVariable: The key specifying which component's state to set.\nvalue: The value to assign to the specified state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_inputs!-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.update_inputs!","text":"update_inputs!(mermaidInt::MermaidIntegrator)\n\nUpdates the input values of each ComponentIntegrator within the given MermaidIntegrator instance based on the outputs of other components and the defined Connectors.\n\nArguments\n\nmermaidInt::MermaidIntegrator: The integrator containing components, connectors, and their current states.\n\nDescription\n\nFor each connector in mermaidInt.connectors, this function:\n\nCollects the outputs from the source components specified in the connector's inputs.\nIf a function (conn.func) is defined for the connector, applies it to the collected inputs to compute the outputs; otherwise, passes the inputs directly.\nAssigns the resulting outputs to the appropriate input fields of the destination components specified in the connector's outputs.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_outputs!-Tuple{Mermaid.ComponentIntegrator}","page":"API","title":"Mermaid.update_outputs!","text":"update_outputs!(compInt::ComponentIntegrator)\n\nUpdate the outputs field of a ComponentIntegrator based on its current state.\n\nArguments\n\ncompInt::ComponentIntegrator: The component integrator whose outputs are to be updated.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.update_solution!-Tuple{MermaidSolution, Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.update_solution!","text":"update_solution!(sol::MermaidSolution, merInt::MermaidIntegrator)\n\nUpdate the MermaidSolution sol with the current time and state from the MermaidIntegrator.\n\nArguments\n\nsol::MermaidSolution: The MermaidSolution to be updated. It contains time points (t) and a dictionary of state histories (u).\nmerInt::MermaidIntegrator: The integrator object providing the current time (currtime) and state access via getstate.\n\nDescription\n\nAppends the current time from merInt to sol.t. For each key in sol.u, retrieves the corresponding state from merInt using getstate and appends it to the respective vector in sol.u.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.AbstractMermaidSolver","page":"API","title":"Mermaid.AbstractMermaidSolver","text":"AbstractMermaidSolver\n\nBase type for all solvers in the Mermaid framework.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AgentsComponent","page":"API","title":"Mermaid.AgentsComponent","text":"AgentsComponent <: AbstractTimeDependentComponent\n\nA component that represents an agent-based model (ABM) using the Agents.jl package.\n\nFields\n\nmodel::StandardABM: The agent-based model to be solved.\nname::String=\"Agents Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping ConnectedVariable names (as strings) to their corresponding properties in the agent model. The properties differentiate between :model properties and :agent properties.\ntime_step::Float64=1.0: The time step for the component (not the ABM solver timestep), i.e. how frequently should the inputs and outputs be updated.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.AgentsComponentIntegrator","page":"API","title":"Mermaid.AgentsComponentIntegrator","text":"AgentsComponentIntegrator <: ComponentIntegrator\n\nA mutable struct that integrates an AgentsComponent using the Agents.jl package.\n\nFields\n\nintegrator::StandardABM: The agent-based model integrator.\ncomponent::AgentsComponent: The AgentsComponent being integrated.\noutputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their initial values from the component.\ninputs::Dict{ConnectedVariable,Any}: A dictionary mapping ConnectedVariable names to their current values (initially 0).\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ComponentIntegrator","page":"API","title":"Mermaid.ComponentIntegrator","text":"ComponentIntegrator\n\nBase type for all component integrators in the Mermaid framework.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable\n\nPoints to a variable that is connected between components.\n\nFields\n\ncomponent::String: Name of the component.\nvariable::String: Name of the variable.\nvariableindex::Union{Nothing,AbstractVector{Int},Int}: Index or range for the variable, if applicable.\nduplicatedindex::Union{Nothing,AbstractVector{Int},Int}: Index for duplicated components, if applicable.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.ConnectedVariable-Tuple{AbstractString}","page":"API","title":"Mermaid.ConnectedVariable","text":"ConnectedVariable(name::AbstractString)\n\nConstruct a ConnectedVariable from a string name.\n\nArguments\n\nname::AbstractString: The full variable name.\n\nReturns\n\nConnectedVariable: The parsed connected variable.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.Connector","page":"API","title":"Mermaid.Connector","text":"Connector\n\nRepresents a connection between multiple ConnectedVariables, possibly with a transformation function.\n\nFields\n\ninputs::Vector{ConnectedVariable}: Input variables for the connector.\noutputs::Vector{ConnectedVariable}: Output variables for the connector.\nfunc::Union{Nothing,Function}: Optional function to transform inputs to outputs.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.Connector-Union{Tuple{}, Tuple{T}, Tuple{S}} where {S<:AbstractString, T<:AbstractString}","page":"API","title":"Mermaid.Connector","text":"Connector(;inputs, outputs, func=nothing)\n\nConstruct a Connector from string names for inputs and outputs.\n\nKeyword Arguments\n\ninputs::Vector{<:AbstractString}: Names of input variables.\noutputs::Vector{<:AbstractString}: Names of output variables.\nfunc: Optional function for transformation (default: nothing).\n\nReturns\n\nConnector: The constructed connector.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.DuplicatedComponent","page":"API","title":"Mermaid.DuplicatedComponent","text":"DuplicatedComponent <: AbstractComponent\n\nRepresents a component that is duplicated in the simulation, allowing a single component to have multiple states.\n\nFields\n\ncomponent::AbstractTimeDependentComponent: The original component to be duplicated.\ninstances::Union{Int,Nothing}: Number of instances of the component. If nothing, then the number is variable and determined by the simulation.\nname::String: Name of the duplicated component.\ninitial_states::Vector: Vector of states for the duplicated component, where each state corresponds to a particular instance.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidIntegrator","page":"API","title":"Mermaid.MermaidIntegrator","text":"MermaidIntegrator\n\nMutable struct for integrating a hybrid MermaidProblem. This struct holds all the ComponentIntegrators and Connectors to store the current state of the hybrid simulation.\n\nFields\n\nintegrators::Vector: Vector of ComponentIntegrator.\nconnectors::Vector{Connector}: Vector of Connector.\nmaxt::Float64: Maximum simulation time.\ncurrtime::Float64: Current simulation time.\nalg::AbstractMermaidSolver: Algorithm used for integration.\nsave_vars::Vector{String}: Variables to save during integration.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidProblem","page":"API","title":"Mermaid.MermaidProblem","text":"MermaidProblem\n\nStruct for defining a Mermaid problem. This struct contains the components, connectors and other properties of the hybrid simulation.\n\nFields\n\ncomponents::Vector: Vector of Components.\nconnectors::Vector{Connector}: Vector of Connector.\nmax_t::Float64=1.0: Maximum simulation time.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution\n\nStruct for storing the solution of a hybrid Mermaid simulation.\n\nFields\n\nt::Vector: Time points.\nu::Dict: Dictionary mapping variables to their solution arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Mermaid.MermaidSolution-Tuple{Mermaid.MermaidIntegrator}","page":"API","title":"Mermaid.MermaidSolution","text":"MermaidSolution(int::MermaidIntegrator)\n\nConstruct a MermaidSolution from a MermaidIntegrator.\n\nArguments\n\nint::MermaidIntegrator: The integrator to extract solution structure from.\n\nReturns\n\nMermaidSolution: The initialized solution object.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.MermaidSolution-Tuple{Real}","page":"API","title":"Mermaid.MermaidSolution","text":"(sol::MermaidSolution)(t::Real)\n\nInterpolates the solution at a given time t using linear interpolation.\n\nArguments\n\nsol::MermaidSolution: The solution object containing time points and state histories.\nt::Real: The time at which to interpolate the solution.\n\nReturns\n\nMermaidSolution: A new MermaidSolution object containing the interpolated time and state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Mermaid.ODEComponent","page":"API","title":"Mermaid.ODEComponent","text":"ODEComponent <: AbstractTimeDependentComponent\n\nA component that represents an ODE system, defined by an ODEProblem.\n\nFields\n\nmodel::ODEProblem: The ODE problem to be solved.\nname::String=\"ODE Component\": The name of the component.\nstate_names::Dict{String,Any} = Dict{String,Any}(): A dictionary mapping variable names (as strings) to their corresponding indices in the state vector or symbols from ModelingToolkit/Symbolics.\ntime_step::Float64=1.0: The time step for the component (not the ODE solver timestep), i.e. how frequently should the inputs and outputs be updated.\nalg=Rodas5(): The algorithm used for solving the ODEProblem.\nintkwargs::Tuple=(): Additional keyword arguments for the ODE solver.\n\n\n\n\n\n","category":"type"}]
}
